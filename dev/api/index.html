<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Tables.jl</title><meta name="title" content="API Reference · Tables.jl"/><meta property="og:title" content="API Reference · Tables.jl"/><meta property="twitter:title" content="API Reference · Tables.jl"/><meta name="description" content="Documentation for Tables.jl."/><meta property="og:description" content="Documentation for Tables.jl."/><meta property="twitter:description" content="Documentation for Tables.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Tables.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../using-the-interface/">Using the Interface</a></li><li><a class="tocitem" href="../implementing-the-interface/">Implementing the Interface</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaData/Tables.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaData/Tables.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.AbstractColumns" href="#Tables.AbstractColumns"><code>Tables.AbstractColumns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.AbstractColumns</code></pre><p>An interface type defined as an ordered set of columns that support retrieval of individual columns by name or index. A retrieved column must be a 1-based indexable collection with known length, i.e. an object that supports <code>length(col)</code> and <code>col[i]</code> for any <code>i = 1:length(col)</code>. <code>Tables.columns</code> must return an object that satisfies the <code>Tables.AbstractColumns</code> interface. While <code>Tables.AbstractColumns</code> is an abstract type that custom &quot;columns&quot; types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects <strong>are not required</strong> to subtype, but only implement the required interface methods.</p><p>Interface definition:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, i::Int)</code></td><td style="text-align: right"><code>getfield(table, i)</code></td><td style="text-align: right">Retrieve a column by index</td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, nm::Symbol)</code></td><td style="text-align: right"><code>getproperty(table, nm)</code></td><td style="text-align: right">Retrieve a column by name</td></tr><tr><td style="text-align: right"><code>Tables.columnnames(table)</code></td><td style="text-align: right"><code>propertynames(table)</code></td><td style="text-align: right">Return column names for a table as a 1-based indexable collection</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol)</code></td><td style="text-align: right"><code>Tables.getcolumn(table, nm)</code></td><td style="text-align: right">Given a column eltype <code>T</code>, index <code>i</code>, and column name <code>nm</code>, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency.</td></tr></table><p>Note that subtypes of <code>Tables.AbstractColumns</code> <strong>must</strong> overload all required methods listed above instead of relying on these methods&#39; default definitions.</p><p>While types aren&#39;t required to subtype <code>Tables.AbstractColumns</code>, benefits of doing so include:</p><ul><li>Indexing interface defined (using <code>getcolumn</code>); i.e. <code>tbl[i]</code> will retrieve the column at index <code>i</code></li><li>Property access interface defined (using <code>columnnames</code> and <code>getcolumn</code>); i.e. <code>tbl.col1</code> will retrieve column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for col in table</code> will iterate each column in the table</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving columns</li><li>A default <code>show</code> method</li></ul><p>This allows a custom table type to behave as close as possible to a builtin <code>NamedTuple</code> of vectors object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L13-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.AbstractRow" href="#Tables.AbstractRow"><code>Tables.AbstractRow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.AbstractRow</code></pre><p>Abstract interface type representing the expected <code>eltype</code> of the iterator returned from <code>Tables.rows(table)</code>. <code>Tables.rows</code> must return an iterator of elements that satisfy the <code>Tables.AbstractRow</code> interface. While <code>Tables.AbstractRow</code> is an abstract type that custom &quot;row&quot; types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects <strong>are not required</strong> to subtype, but only implement the required interface methods.</p><p>Interface definition:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, i::Int)</code></td><td style="text-align: right"><code>getfield(row, i)</code></td><td style="text-align: right">Retrieve a column value by index</td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, nm::Symbol)</code></td><td style="text-align: right"><code>getproperty(row, nm)</code></td><td style="text-align: right">Retrieve a column value by name</td></tr><tr><td style="text-align: right"><code>Tables.columnnames(row)</code></td><td style="text-align: right"><code>propertynames(row)</code></td><td style="text-align: right">Return column names for a row as a 1-based indexable collection</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol)</code></td><td style="text-align: right"><code>Tables.getcolumn(row, nm)</code></td><td style="text-align: right">Given a column element type <code>T</code>, index <code>i</code>, and column name <code>nm</code>, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency.</td></tr></table><p>Note that subtypes of <code>Tables.AbstractRow</code> <strong>must</strong> overload all required methods listed above instead of relying on these methods&#39; default definitions.</p><p>While custom row types aren&#39;t required to subtype <code>Tables.AbstractRow</code>, benefits of doing so include:</p><ul><li>Indexing interface defined (using <code>getcolumn</code>); i.e. <code>row[i]</code> will return the column value at index <code>i</code></li><li>Property access interface defined (using <code>columnnames</code> and <code>getcolumn</code>); i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column value in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving column values</li><li>A default <code>show</code> method</li></ul><p>This allows the custom row type to behave as close as possible to a builtin <code>NamedTuple</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L49-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.ByRow" href="#Tables.ByRow"><code>Tables.ByRow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ByRow &lt;: Function</code></pre><p><code>ByRow(f)</code> returns a function which applies function <code>f</code> to each element in a vector.</p><p><code>ByRow(f)</code> can be passed two types of arguments:</p><ul><li>One or more 1-based <code>AbstractVector</code>s of equal length: In this case the returned value is a vector resulting from applying <code>f</code> to elements of passed vectors element-wise. Function <code>f</code> is called exactly once for each element of passed vectors (as opposed to <code>map</code> which assumes for some types of source vectors (e.g. <code>SparseVector</code>) that the wrapped function is pure, and may call the function <code>f</code> only once for multiple equal values.</li><li>A <code>Tables.ColumnTable</code> holding 1-based columns of equal length: In this case the function <code>f</code> is passed a <code>NamedTuple</code> created for each row of passed table.</li></ul><p>The return value of <code>ByRow(f)</code> is always a vector.</p><p><code>ByRow</code> expects that at least one argument is passed to it and in the case of <code>Tables.ColumnTable</code> passed that the table has at least one column. In some contexts of operations on tables (for example <code>DataFrame</code>) the user might want to pass no arguments (or an empty <code>Tables.ColumnTable</code>) to <code>ByRow</code>. This case must be separately handled by the code implementing the logic of processing the <code>ByRow</code> operation on this specific parent table (the reason is that passing such arguments to <code>ByRow</code> does not allow it to determine the number of rows of the source table).</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; Tables.ByRow(x -&gt; x^2)(1:3)
3-element Vector{Int64}:
 1
 4
 9

julia&gt; Tables.ByRow((x, y) -&gt; x*y)(1:3, 2:4)
3-element Vector{Int64}:
  2
  6
 12

julia&gt; Tables.ByRow(x -&gt; x.a)((a=1:2, b=3:4))
2-element Vector{Int64}:
 1
 2

 julia&gt; Tables.ByRow(x -&gt; (a=x.a*2, b=sin(x.b), c=x.c))((a=[1, 2, 3],
                                                         b=[1.2, 3.4, 5.6],
                                                         c=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]))
3-element Vector{NamedTuple{(:a, :b, :c), Tuple{Int64, Float64, String}}}:
 (a = 2, b = 0.9320390859672263, c = &quot;a&quot;)
 (a = 4, b = -0.2555411020268312, c = &quot;b&quot;)
 (a = 6, b = -0.6312666378723216, c = &quot;c&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/utils.jl#L164-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.Columns" href="#Tables.Columns"><code>Tables.Columns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.Columns(tbl)</code></pre><p>Convenience type that calls <code>Tables.columns</code> on an input <code>tbl</code> and wraps the resulting <code>AbstractColumns</code> interface object in a dedicated struct to provide useful default behaviors (allows any <code>AbstractColumns</code> to be used like a <code>NamedTuple</code> of <code>Vectors</code>):</p><ul><li>Indexing interface defined; i.e. <code>row[i]</code> will return the column at index <code>i</code>, <code>row[nm]</code> will return column for column name <code>nm</code></li><li>Property access interface defined; i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving columns</li></ul><p>Note that <code>Tables.Columns</code> calls <code>Tables.columns</code> internally on the provided table argument. <code>Tables.Columns</code> can be used for dispatch if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L257-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.CopiedColumns" href="#Tables.CopiedColumns"><code>Tables.CopiedColumns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.CopiedColumns</code></pre><p>For some sinks, there&#39;s a concern about whether they can safely &quot;own&quot; columns from the input. If mutation will be allowed, to be safe, they should always copy input columns, to avoid unintended mutation to the original source. When we&#39;ve called <code>buildcolumns</code>, however, Tables.jl essentially built/owns the columns, and it&#39;s happy to pass ownership to the sink. Thus, any built columns will be wrapped in a <code>CopiedColumns</code> struct to signal to the sink that essentially &quot;a copy has already been made&quot; and they&#39;re safe to assume ownership.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/fallbacks.jl#L230-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.LazyTable" href="#Tables.LazyTable"><code>Tables.LazyTable</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.LazyTable(f, arg)</code></pre><p>A &quot;table&quot; type that delays materialization until <code>Tables.columns</code> or <code>Tables.rows</code> is called. This allows, for example, sending a <code>LazyTable</code> to a remote process or thread which can then call <code>Tables.columns</code> or <code>Tables.rows</code> to &quot;materialize&quot; the table. Is used by default in <code>Tables.partitioner(f, itr)</code> where a materializer function <code>f</code> is passed to each element of an iterable <code>itr</code>, allowing distributed/concurrent patterns like:</p><pre><code class="language-julia hljs">for tbl in Tables.partitions(Tables.partitioner(CSV.File, list_of_csv_files))
    Threads.@spawn begin
        cols = Tables.columns(tbl)
        # do stuff with cols
    end
end</code></pre><p>In this example, <code>CSV.File</code> will be called like <code>CSV.File(x)</code> for each element of the <code>list_of_csv_files</code> iterable, but <em>not until</em> <code>Tables.columns(tbl)</code> is called, which in this case happens in a thread-spawned task, allowing files to be parsed and processed in parallel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L563-L584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.Row" href="#Tables.Row"><code>Tables.Row</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.Row(row)</code></pre><p>Convenience type to wrap any <code>AbstractRow</code> interface object in a dedicated struct to provide useful default behaviors (allows any <code>AbstractRow</code> to be used like a <code>NamedTuple</code>):</p><ul><li>Indexing interface defined; i.e. <code>row[i]</code> will return the column value at index <code>i</code>, <code>row[nm]</code> will return column value for column name <code>nm</code></li><li>Property access interface defined; i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column value in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving column values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L241-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.Schema" href="#Tables.Schema"><code>Tables.Schema</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.Schema(names, types)</code></pre><p>Create a <code>Tables.Schema</code> object that holds the column names and types for an <code>AbstractRow</code> iterator returned from <code>Tables.rows</code> or an <code>AbstractColumns</code> object returned from <code>Tables.columns</code>. <code>Tables.Schema</code> is dual-purposed: provide an easy interface for users to query these properties, as well as provide a convenient &quot;structural&quot; type for code generation.</p><p>To get a table&#39;s schema, one can call <code>Tables.schema</code> on the result of <code>Tables.rows</code> or <code>Tables.columns</code>, but also note that a table may return <code>nothing</code>, indicating that its column names and/or column element types are unknown (usually not inferable). This is similar to the <code>Base.EltypeUnknown()</code> trait for iterators when <code>Base.IteratorEltype</code> is called. Users should account for the <code>Tables.schema(tbl) =&gt; nothing</code> case by using the properties of the results of <code>Tables.rows(x)</code> and <code>Tables.columns(x)</code> directly.</p><p>To access the names, one can simply call <code>sch.names</code> to return a collection of Symbols (<code>Tuple</code> or <code>Vector</code>). To access column element types, one can similarly call <code>sch.types</code>, which will return a collection of types (like <code>(Int64, Float64, String)</code>).</p><p>The actual type definition is</p><pre><code class="language-julia hljs">struct Schema{names, types}
    storednames::Union{Nothing, Vector{Symbol}}
    storedtypes::Union{Nothing, Vector{Type}}
end</code></pre><p>Where <code>names</code> is a tuple of <code>Symbol</code>s or <code>nothing</code>, and <code>types</code> is a tuple <em>type</em> of types (like <code>Tuple{Int64, Float64, String}</code>) or <code>nothing</code>. Encoding the names &amp; types as type parameters allows convenient use of the type in generated functions and other optimization use-cases, but users should note that when <code>names</code> and/or <code>types</code> are the <code>nothing</code> value, the names and/or types are stored in the <code>storednames</code> and <code>storedtypes</code> fields. This is to account for extremely wide tables with columns in the 10s of thousands where encoding the names/types as type parameters becomes prohibitive to the compiler. So while optimizations can be written on the typed <code>names</code>/<code>types</code> type parameters, users should also consider handling the extremely wide tables by specializing on <code>Tables.Schema{nothing, nothing}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L435-L465">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.allocatecolumn-Tuple{Any, Any}" href="#Tables.allocatecolumn-Tuple{Any, Any}"><code>Tables.allocatecolumn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.allocatecolumn(::Type{T}, len) =&gt; returns a column type (usually `AbstractVector`) with size to hold `len` elements</code></pre><p>Custom column types can override with an appropriate &quot;scalar&quot; element type that should dispatch to their column allocator. Alternatively, and more generally, custom scalars can overload <code>DataAPI.defaultarray</code> to signal the default array type. In this case the signaled array type must support a constructor accepting <code>undef</code> for initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/fallbacks.jl#L108-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columnaccess" href="#Tables.columnaccess"><code>Tables.columnaccess</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.columnaccess(x) =&gt; Bool</code></pre><p>Check whether an object has specifically defined that it implements the <code>Tables.columns</code> function that does <em>not</em> copy table data.  That is to say, <code>Tables.columns(x)</code> must be done with O(1) time and space complexity when <code>Tables.columnaccess(x) == true</code>.  Note that <code>Tables.columns</code> has generic fallbacks allowing it to produces <code>AbstractColumns</code> objects, even if the input doesn&#39;t define <code>columnaccess</code>.  However, this generic fallback may copy the data from input table <code>x</code>.  Also note that just because an object defines <code>columnaccess</code> doesn&#39;t mean a user should call <code>Tables.columns</code> on it; <code>Tables.rows</code> will also work, providing a valid <code>AbstractRow</code> iterator. Hence, users should call <code>Tables.rows</code> or <code>Tables.columns</code> depending on what is most natural for them to <em>consume</em> instead of worrying about what and how the input is oriented.</p><p>It is recommended that for users implementing <code>MyType</code>, they define only <code>columnaccess(::Type{MyType})</code>. <code>columnaccess(::MyType)</code> will then automatically delegate to this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L341-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columnindex-Tuple{Any, Symbol}" href="#Tables.columnindex-Tuple{Any, Symbol}"><code>Tables.columnindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.columnindex(table, name::Symbol)</code></pre><p>Return the column index (1-based) of a column by <code>name</code> in a table with a known schema; returns 0 if <code>name</code> doesn&#39;t exist in table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L709-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columnindex-Tuple{Tuple{Vararg{Symbol}}, Symbol}" href="#Tables.columnindex-Tuple{Tuple{Vararg{Symbol}}, Symbol}"><code>Tables.columnindex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>given names and a Symbol <code>name</code>, compute the index (1-based) of the name in names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L725">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columnnames" href="#Tables.columnnames"><code>Tables.columnnames</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.columnnames(::Union{AbstractColumns, AbstractRow}) =&gt; Indexable collection</code></pre><p>Retrieves the list of column names as a 1-based indexable collection (like a <code>Tuple</code> or <code>Vector</code>) for a <code>AbstractColumns</code> or <code>AbstractRow</code> interface object. The default definition calls <code>propertynames(x)</code>. The returned column names must be unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columns" href="#Tables.columns"><code>Tables.columns</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.columns(x) =&gt; AbstractColumns-compatible object</code></pre><p>Accesses data of input table source <code>x</code> by returning an <a href="#Tables.AbstractColumns"><code>AbstractColumns</code></a>-compatible object, which allows retrieving entire columns by name or index. A retrieved column is a 1-based indexable object that has a known length, i.e. supports <code>length(col)</code> and <code>col[i]</code> for any <code>i = 1:length(col)</code>. Note that even if the input table source is row-oriented by nature, an efficient generic definition of <code>Tables.columns</code> is defined in Tables.jl to build a <code>AbstractColumns</code>- compatible object object from the input rows.</p><p>The <a href="#Tables.Schema"><code>Tables.Schema</code></a> of a <code>AbstractColumns</code> object can be queried via <code>Tables.schema(columns)</code>, which may return <code>nothing</code> if the schema is unknown. Column names can always be queried by calling <code>Tables.columnnames(columns)</code>, and individual columns can be accessed by calling <code>Tables.getcolumn(columns, i::Int )</code> or <code>Tables.getcolumn(columns, nm::Symbol)</code> with a column index or name, respectively.</p><p>Note that if <code>x</code> is an object in which columns are stored as vectors, the check that these vectors use 1-based indexing is not performed (it should be ensured when <code>x</code> is constructed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L394-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columntable" href="#Tables.columntable"><code>Tables.columntable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.columntable(x) =&gt; NamedTuple of AbstractVectors</code></pre><p>Takes any input table source <code>x</code> and returns a <code>NamedTuple</code> of <code>AbstractVector</code>s, also known as a &quot;column table&quot;. A &quot;column table&quot; is a kind of default table type of sorts, since it satisfies the Tables.jl column interface naturally.</p><p>Note that if <code>x</code> is an object in which columns are stored as vectors, the check that these vectors use 1-based indexing is not performed (it should be ensured when <code>x</code> is constructed).</p><p>Not for use with extremely wide tables with # of columns &gt; 67K; current fundamental compiler limits prevent constructing <code>NamedTuple</code>s that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/namedtuples.jl#L145-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columntype-Tuple{Any, Symbol}" href="#Tables.columntype-Tuple{Any, Symbol}"><code>Tables.columntype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.columntype(table, name::Symbol)</code></pre><p>Return the column element type of a column by <code>name</code> in a table with a known schema; returns Union{} if <code>name</code> doesn&#39;t exist in table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L716-L720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.columntype-Union{Tuple{types}, Tuple{Tuple{Vararg{Symbol}}, Type{types}, Symbol}} where types&lt;:Tuple" href="#Tables.columntype-Union{Tuple{types}, Tuple{Tuple{Vararg{Symbol}}, Type{types}, Symbol}} where types&lt;:Tuple"><code>Tables.columntype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>given tuple type and a Symbol <code>name</code>, compute the type of the name in the tuples types</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.datavaluerows-Tuple{Any}" href="#Tables.datavaluerows-Tuple{Any}"><code>Tables.datavaluerows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.datavaluerows(x) =&gt; NamedTuple iterator</code></pre><p>Takes any table input <code>x</code> and returns a <code>NamedTuple</code> iterator that will replace missing values with <code>DataValue</code>-wrapped values; this allows any table type to satisfy the TableTraits.jl  Queryverse integration interface by defining: </p><pre><code class="nohighlight hljs">IteratorInterfaceExtensions.getiterator(x::MyTable) = Tables.datavaluerows(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/tofromdatavalues.jl#L82-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.dictcolumntable-Tuple{Any}" href="#Tables.dictcolumntable-Tuple{Any}"><code>Tables.dictcolumntable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.dictcolumntable(x) =&gt; Tables.DictColumnTable</code></pre><p>Take any Tables.jl-compatible source <code>x</code> and return a <code>DictColumnTable</code>, which can be thought of as a <code>OrderedDict</code> mapping column names as <code>Symbol</code>s to <code>AbstractVector</code>s. The order of the input table columns is preserved via the <code>Tables.schema(::DictColumnTable)</code>.</p><p>For &quot;schema-less&quot; input tables, <code>dictcolumntable</code> employs a &quot;column unioning&quot; behavior, as opposed to inferring the schema from the first row like <code>Tables.columns</code>. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value <code>missing</code>, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it&#39;s recommended to use only when needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/dicts.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.dictrowtable-Tuple{Any}" href="#Tables.dictrowtable-Tuple{Any}"><code>Tables.dictrowtable</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.dictrowtable(x) =&gt; Tables.DictRowTable</code></pre><p>Take any Tables.jl-compatible source <code>x</code> and return a <code>DictRowTable</code>, which can be thought of as a <code>Vector</code> of <code>OrderedDict</code> rows mapping column names as <code>Symbol</code>s to values. The order of the input table columns is preserved via the <code>Tables.schema(::DictRowTable)</code>.</p><p>For &quot;schema-less&quot; input tables, <code>dictrowtable</code> employs a &quot;column unioning&quot; behavior, as opposed to inferring the schema from the first row like <code>Tables.columns</code>. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value <code>missing</code>, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it&#39;s recommended to use only when the union behavior is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/dicts.jl#L141-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.eachcolumn" href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.eachcolumn(f, sch::Tables.Schema{names, types}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})
Tables.eachcolumn(f, sch::Tables.Schema{names, nothing}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})</code></pre><p>Takes a function <code>f</code>, table schema <code>sch</code>, <code>x</code>, which is an object that satisfies the <code>AbstractRow</code> or <code>AbstractColumns</code> interfaces; it generates calls to get the value for each column (<code>Tables.getcolumn(x, nm)</code>) and then calls <code>f(val, index, name)</code>, where <code>f</code> is the user-provided function, <code>val</code> is the column value (<code>AbstractRow</code>) or entire column (<code>AbstractColumns</code>), <code>index</code> is the column index as an <code>Int</code>, and <code>name</code> is the column name as a <code>Symbol</code>.</p><p>An example using <code>Tables.eachcolumn</code> is:</p><pre><code class="language-julia hljs">rows = Tables.rows(tbl)
sch = Tables.schema(rows)
if sch === nothing
    state = iterate(rows)
    state === nothing &amp;&amp; return
    row, st = state
    sch = Tables.schema(Tables.columnnames(row), nothing)
    while state !== nothing
        Tables.eachcolumn(sch, row) do val, i, nm
            bind!(stmt, i, val)
        end
        state = iterate(rows, st)
        state === nothing &amp;&amp; return
        row, st = state
    end
else
    for row in rows
        Tables.eachcolumn(sch, row) do val, i, nm
            bind!(stmt, i, val)
        end
    end
end</code></pre><p>Note in this example we account for the input table potentially returning <code>nothing</code> from <code>Tables.schema(rows)</code>; in that case, we start iterating the rows, and build a partial schema using the column names from the first row <code>sch = Tables.schema(Tables.columnnames(row), nothing)</code>, which is valid to pass to <code>Tables.eachcolumn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/utils.jl#L22-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.getcolumn" href="#Tables.getcolumn"><code>Tables.getcolumn</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.getcolumn(::AbstractColumns, nm::Symbol) =&gt; Indexable collection with known length
Tables.getcolumn(::AbstractColumns, i::Int) =&gt; Indexable collection with known length
Tables.getcolumn(::AbstractColumns, T, i::Int, nm::Symbol) =&gt; Indexable collection with known length

Tables.getcolumn(::AbstractRow, nm::Symbol) =&gt; Column value
Tables.getcolumn(::AbstractRow, i::Int) =&gt; Column value
Tables.getcolumn(::AbstractRow, T, i::Int, nm::Symbol) =&gt; Column value</code></pre><p>Retrieve an entire column (from <code>AbstractColumns</code>) or single row column value (from an <code>AbstractRow</code>) by column name (<code>nm</code>), index (<code>i</code>), or if desired, by column element type (<code>T</code>), index (<code>i</code>), and name (<code>nm</code>). When called on a <code>AbstractColumns</code> interface object, the returned object should be a 1-based indexable collection with known length. When called on a <code>AbstractRow</code> interface object, it returns the single column value. The methods taking a single <code>Symbol</code> or <code>Int</code> are both required for the <code>AbstractColumns</code> and <code>AbstractRow</code> interfaces; the third method is optional if type stability is possible. The default definition of <code>Tables.getcolumn(x, i::Int)</code> is <code>getfield(x, i)</code>. The default definition of <code>Tables.getcolumn(x, nm::Symbol)</code> is <code>getproperty(x, nm)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L82-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.isrowtable" href="#Tables.isrowtable"><code>Tables.isrowtable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.isrowtable(x) =&gt; Bool</code></pre><p>For convenience, some table objects that are naturally &quot;row oriented&quot; can define <code>Tables.isrowtable(::Type{TableType}) = true</code> to simplify satisfying the Tables.jl interface. Requirements for defining <code>isrowtable</code> include:</p><ul><li><code>Tables.rows(x) === x</code>, i.e. the table object itself is a <code>Row</code> iterator</li><li>If the table object is mutable, it should support:<ul><li><code>push!(x, row)</code>: allow pushing a single row onto table</li><li><code>append!(x, rows)</code>: allow appending set of rows onto table</li></ul></li><li>If table object is mutable and indexable, it should support:<ul><li><code>x[i] = row</code>: allow replacing of a row with another row by index</li></ul></li></ul><p>A table object that defines <code>Tables.isrowtable</code> will have definitions for <code>Tables.istable</code>, <code>Tables.rowaccess</code>, and <code>Tables.rows</code> automatically defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L118-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.istable" href="#Tables.istable"><code>Tables.istable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.istable(x) =&gt; Bool</code></pre><p>Check if an object has specifically defined that it is a table. Note that not all valid tables will return true, since it&#39;s possible to satisfy the Tables.jl interface at &quot;run-time&quot;, e.g. a <code>Generator</code> of <code>NamedTuple</code>s iterates <code>NamedTuple</code>s, which satisfies the <code>AbstractRow</code> interface, but there&#39;s no static way of knowing that the generator is a table.</p><p>It is recommended that for users implementing <code>MyType</code>, they define only <code>istable(::Type{MyType})</code>. <code>istable(::MyType)</code> will then automatically delegate to this method.</p><p><code>istable</code> calls <code>TableTraits.isiterabletable</code> as a fallback. This can have a considerable runtime overhead in some contexts. To avoid these and use <code>istable</code> as a compile-time trait, it can be called on a type as <code>istable(typeof(obj))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L293-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.materializer" href="#Tables.materializer"><code>Tables.materializer</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.materializer(x) =&gt; Callable</code></pre><p>For a table input, return the &quot;sink&quot; function or &quot;materializing&quot; function that can take a Tables.jl-compatible table input and make an instance of the table type. This enables &quot;transform&quot; workflows that take table inputs, apply transformations, potentially converting the table to a different form, and end with producing a table of the same type as the original input. The default materializer is <code>Tables.columntable</code>, which converts any table input into a <code>NamedTuple</code> of <code>Vector</code>s.</p><p>It is recommended that for users implementing <code>MyType</code>, they define only <code>materializer(::Type{&lt;:MyType})</code>. <code>materializer(::MyType)</code> will then automatically delegate to this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L375-L388">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.matrix-Tuple{Any}" href="#Tables.matrix-Tuple{Any}"><code>Tables.matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.matrix(table; transpose::Bool=false)</code></pre><p>Materialize any table source input as a new <code>Matrix</code> or in the case of a <code>MatrixTable</code> return the originally wrapped matrix. If the table column element types are not homogeneous, they will be promoted to a common type in the materialized <code>Matrix</code>. Note that column names are ignored in the conversion. By default, input table columns will be materialized as corresponding matrix columns; passing <code>transpose=true</code> will transpose the input with input columns as matrix rows or in the case of a <code>MatrixTable</code> apply <code>permutedims</code> to the originally wrapped matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/matrix.jl#L74-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.namedtupleiterator-Tuple{Any}" href="#Tables.namedtupleiterator-Tuple{Any}"><code>Tables.namedtupleiterator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.namedtupleiterator(x)</code></pre><p>Pass any table input source and return a <code>NamedTuple</code> iterator</p><p>See also <a href="#Tables.rows"><code>rows</code></a> and <a href="#Tables.rowtable"><code>rowtable</code></a>.</p><p>Not for use with extremely wide tables with # of columns &gt; 67K; current fundamental compiler limits prevent constructing <code>NamedTuple</code>s that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/namedtuples.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.nondatavaluerows-Tuple{Any}" href="#Tables.nondatavaluerows-Tuple{Any}"><code>Tables.nondatavaluerows</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.nondatavaluerows(x)</code></pre><p>Takes any Queryverse-compatible <code>NamedTuple</code> iterator source and  converts to a Tables.jl-compatible <code>AbstractRow</code> iterator. Will automatically unwrap any <code>DataValue</code>s, replacing <code>NA</code> with <code>missing</code>. Useful for translating Query.jl results back to non-<code>DataValue</code>-based tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/tofromdatavalues.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.partitioner-Tuple{Any}" href="#Tables.partitioner-Tuple{Any}"><code>Tables.partitioner</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.partitioner(f, itr)
Tables.partitioner(x)</code></pre><p>Convenience methods to generate table iterators. The first method takes a &quot;materializer&quot; function <code>f</code> and an iterator <code>itr</code>, and will call <code>Tables.LazyTable(f, x) for x in itr</code> for each iteration. This allows delaying table materialization until <code>Tables.columns</code> or <code>Tables.rows</code> are called on the <code>LazyTable</code> object (which will call <code>f(x)</code>). This allows a common desired pattern of materializing and processing a table on a remote process or thread, like:</p><pre><code class="language-julia hljs">for tbl in Tables.partitions(Tables.partitioner(CSV.File, list_of_csv_files))
    Threads.@spawn begin
        cols = Tables.columns(tbl)
        # do stuff with cols
    end
end</code></pre><p>The second method is provided because the default behavior of <code>Tables.partition(x)</code> is to treat <code>x</code> as a single, non-partitioned table. This method allows users to easily wrap a <code>Vector</code> or generator of tables as table partitions to pass to sink functions able to utilize <code>Tables.partitions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L652-L676">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.partitions-Tuple{Any}" href="#Tables.partitions-Tuple{Any}"><code>Tables.partitions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.partitions(x)</code></pre><p>Request a &quot;table&quot; iterator from <code>x</code>. Each iterated element must be a &quot;table&quot; in the sense that one may call <code>Tables.rows</code> or <code>Tables.columns</code> to get a row-iterator or collection of columns. All iterated elements <em>must</em> have identical schema, so that users may call <code>Tables.schema(first_element)</code> on the first iterated element and know that each subsequent iteration will match the same schema. The default definition is:</p><pre><code class="language-julia hljs">Tables.partitions(x) = (x,)</code></pre><p>So that any input is assumed to be a single &quot;table&quot;. This means users should feel free to call <code>Tables.partitions</code> anywhere they&#39;re currently calling <code>Tables.columns</code> or <code>Tables.rows</code>, and get back an iterator of those instead. In other words, &quot;sink&quot; functions can use <code>Tables.partitions</code> whether or not the user passes a partionable table, since the default is to treat a single input as a single, non-partitioned table.</p><p><a href="#Tables.partitioner-Tuple{Any}"><code>Tables.partitioner(itr)</code></a> is a convenience wrapper to provide table partitions from any table iterator; this allows for easy wrapping of a <code>Vector</code> or iterator of tables as valid partitions, since by default, they&#39;d be treated as a single table.</p><p>A 2nd convenience method is provided with the definition:</p><pre><code class="language-julia hljs">Tables.partitions(x...) = x</code></pre><p>That allows passing vararg tables and they&#39;ll be treated as separate partitions. Sink functions may allow vararg table inputs and can &quot;splat them through&quot; to <code>partitions</code>.</p><p>For convenience, <code>Tables.partitions(x::Iterators.PartitionIterator) = x</code> and <code>Tables.partitions(x::Tables.Partitioner) = x</code> are defined to handle cases where user created partitioning with the <code>Iterators.partition</code> or <a href="#Tables.partitioner-Tuple{Any}"><code>Tables.partitioner</code></a> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L526-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.rowaccess" href="#Tables.rowaccess"><code>Tables.rowaccess</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.rowaccess(x) =&gt; Bool</code></pre><p>Check whether an object has specifically defined that it implements the <code>Tables.rows</code> function that does <em>not</em> copy table data.  That is to say, <code>Tables.rows(x)</code> must be done with O(1) time and space complexity when <code>Tables.rowaccess(x) == true</code>.  Note that <code>Tables.rows</code> will work on any object that iterates <code>AbstractRow</code>-compatible objects, even if they don&#39;t define <code>rowaccess</code>, e.g. a <code>Generator</code> of <code>NamedTuple</code>s.  However, this generic fallback may copy the data from input table <code>x</code>.  Also note that just because an object defines <code>rowaccess</code> doesn&#39;t mean a user should call <code>Tables.rows</code> on it; <code>Tables.columns</code> will also work, providing a valid <code>AbstractColumns</code> object from the rows. Hence, users should call <code>Tables.rows</code> or <code>Tables.columns</code> depending on what is most natural for them to <em>consume</em> instead of worrying about what and how the input is oriented.</p><p>It is recommended that for users implementing <code>MyType</code>, they define only <code>rowaccess(::Type{MyType})</code>. <code>rowaccess(::MyType)</code> will then automatically delegate to this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L318-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.rowmerge-Tuple{Any, Any}" href="#Tables.rowmerge-Tuple{Any, Any}"><code>Tables.rowmerge</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rowmerge(row, other_rows...)
rowmerge(row; fields_to_merge...)</code></pre><p>Return a <code>NamedTuple</code> by merging <code>row</code> (an <code>AbstractRow</code>-compliant value) with <code>other_rows</code> (one or more <code>AbstractRow</code>-compliant values) via <code>Base.merge</code>. This function is similar to <code>Base.merge(::NamedTuple, ::NamedTuple...)</code>, but accepts <code>AbstractRow</code>-compliant values instead of <code>NamedTuple</code>s.</p><p>A convenience method <code>rowmerge(row; fields_to_merge...) = rowmerge(row, fields_to_merge)</code> is defined that enables the <code>fields_to_merge</code> to be specified as keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/utils.jl#L145-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.rows" href="#Tables.rows"><code>Tables.rows</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.rows(x) =&gt; Row iterator</code></pre><p>Accesses data of input table source <code>x</code> row-by-row by returning an <a href="#Tables.AbstractRow"><code>AbstractRow</code></a>-compatible iterator. Note that even if the input table source is column-oriented by nature, an efficient generic definition of <code>Tables.rows</code> is defined in Tables.jl to return an iterator of row views into the columns of the input.</p><p>The <a href="#Tables.Schema"><code>Tables.Schema</code></a> of an <code>AbstractRow</code> iterator can be queried via <code>Tables.schema(rows)</code>, which may return <code>nothing</code> if the schema is unknown. Column names can always be queried by calling <code>Tables.columnnames(row)</code> on an individual row, and row values can be accessed by calling <code>Tables.getcolumn(row, i::Int )</code> or <code>Tables.getcolumn(row, nm::Symbol)</code> with a column index or name, respectively.</p><p>See also <a href="#Tables.rowtable"><code>rowtable</code></a> and <a href="#Tables.namedtupleiterator-Tuple{Any}"><code>namedtupleiterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L416-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.rowtable" href="#Tables.rowtable"><code>Tables.rowtable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.rowtable(x) =&gt; Vector{NamedTuple}</code></pre><p>Take any input table source, and produce a <code>Vector</code> of <code>NamedTuple</code>s, also known as a &quot;row table&quot;. A &quot;row table&quot; is a kind of default table type of sorts, since it satisfies the Tables.jl row interface naturally, i.e. a <code>Vector</code> naturally iterates its elements, and <code>NamedTuple</code> satisfies the <code>AbstractRow</code> interface by default (allows indexing value by index, name, and getting all names).</p><p>For a lazy iterator over rows see <a href="#Tables.rows"><code>rows</code></a> and <a href="#Tables.namedtupleiterator-Tuple{Any}"><code>namedtupleiterator</code></a>.</p><p>Not for use with extremely wide tables with # of columns &gt; 67K; current fundamental compiler limits prevent constructing <code>NamedTuple</code>s that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/namedtuples.jl#L87-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.runlength-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Tuple" href="#Tables.runlength-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Tuple"><code>Tables.runlength</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>helper function to calculate a run-length encoding of a tuple type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/utils.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.schema" href="#Tables.schema"><code>Tables.schema</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.schema(x) =&gt; Union{Nothing, Tables.Schema}</code></pre><p>Attempt to retrieve the schema of the object returned by <code>Tables.rows</code> or <code>Tables.columns</code>. If the <code>AbstractRow</code> iterator or <code>AbstractColumns</code> object can&#39;t determine its schema, <code>nothing</code> will be returned. Otherwise, a <code>Tables.Schema</code> object is returned, with the column names and types available for use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L364-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.subset-Union{Tuple{T}, Tuple{T, Any}} where T" href="#Tables.subset-Union{Tuple{T}, Tuple{T, Any}} where T"><code>Tables.subset</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.subset(x, inds; viewhint=nothing)</code></pre><p>Return one or more rows from table <code>x</code> according to the position(s) specified by <code>inds</code>:</p><ul><li>If <code>inds</code> is a single non-boolean integer return a row object.</li><li>If <code>inds</code> is a vector of non-boolean integers, a vector of booleans, or a <code>:</code>, return a subset of the original table according to the indices. In this case, the returned type is not necessarily the same as the original table type.</li></ul><p>If other types of <code>inds</code> are passed than specified above the behavior is undefined.</p><p>The <code>viewhint</code> argument tries to influence whether the returned object is a view of the original table or an independent copy:</p><ul><li>If <code>viewhint=nothing</code> (the default) then the implementation for a specific table type is free to decide  whether to return a copy or a view.</li><li>If <code>viewhint=true</code> then a view is returned and if <code>viewhint=false</code> a copy is returned. This applies both to returning a row or a table.</li></ul><p>Any specialized implementation of <code>subset</code> must support the <code>viewhint=nothing</code> argument. Support for <code>viewhint=true</code> or <code>viewhint=false</code> is optional (i.e. implementations may ignore the keyword argument and return a view or a copy regardless of <code>viewhint</code> value).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L597-L619">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.table-Tuple{AbstractVecOrMat}" href="#Tables.table-Tuple{AbstractVecOrMat}"><code>Tables.table</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.table(m::AbstractVecOrMat; [header])</code></pre><p>Wrap an <code>AbstractVecOrMat</code> (<code>Matrix</code>, <code>Vector</code>, <code>Adjoint</code>, etc.) in a <code>MatrixTable</code>, which satisfies the Tables.jl interface.  (An <code>AbstractVector</code> is treated as a 1-column matrix.) This allows accessing the matrix via <code>Tables.rows</code> and <code>Tables.columns</code>. An optional keyword argument iterator <code>header</code> can be passed which will be converted to a <code>Vector{Symbol}</code> to be used as the column names. Note that no copy of the <code>AbstractVecOrMat</code> is made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/matrix.jl#L56-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../implementing-the-interface/">« Implementing the Interface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 4 June 2025 13:24">Wednesday 4 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
