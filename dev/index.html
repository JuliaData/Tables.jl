<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Tables.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Tables.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)"><span>Using the Interface (i.e. consuming Tables.jl-compatible sources)</span></a></li><li><a class="tocitem" href="#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)"><span>Implementing the Interface (i.e. becoming a Tables.jl source)</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/Tables.jl/blob/main/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tables.jl-Documentation"><a class="docs-heading-anchor" href="#Tables.jl-Documentation">Tables.jl Documentation</a><a id="Tables.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.jl-Documentation" title="Permalink"></a></h1><p>This guide provides documentation around the powerful tables interfaces in the Tables.jl package. Note that the package, and hence, documentation, are geared towards package and library developers who intend to implement and consume the interfaces. Users, on the other hand, benefit from these other packages that provide useful access to table data in various formats or workflows. While everyone is encouraged to understand the interfaces and the functionality they allow, just note that most users don&#39;t need to use Tables.jl directly.</p><p>With that said, don&#39;t hesitate to <a href="https://github.com/JuliaData/Tables.jl/issues/new">open a new issue</a>, even just for a question, or come chat with us on the <a href="https://julialang.slack.com/messages/data/">#data</a> slack channel with questions, concerns, or clarifications. Also one can find list of packages that supports Tables.jl interface in <a href="https://github.com/JuliaData/Tables.jl/blob/master/INTEGRATIONS.md">INTEGRATIONS.md</a>.</p><p>Please refer to <a href="https://github.com/JuliaData/TableOperations.jl">TableOperations.jl</a> for common table operations such as  <code>select</code>, <code>transform</code>, <code>filter</code> and  <code>map</code>.</p><ul><li><a href="#Tables.jl-Documentation">Tables.jl Documentation</a></li><li class="no-marker"><ul><li><a href="#Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)">Using the Interface (i.e. consuming Tables.jl-compatible sources)</a></li><li class="no-marker"><ul><li><a href="#Tables.rows-usage"><code>Tables.rows</code> usage</a></li><li><a href="#Tables.columns-usage"><code>Tables.columns</code> usage</a></li><li><a href="#Tables.jl-Utilities">Tables.jl Utilities</a></li></ul></li><li><a href="#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)">Implementing the Interface (i.e. becoming a Tables.jl source)</a></li><li class="no-marker"><ul><li><a href="#Tables.AbstractRow"><code>Tables.AbstractRow</code></a></li><li><a href="#Tables.AbstractColumns"><code>Tables.AbstractColumns</code></a></li><li><a href="#Implementation-Example">Implementation Example</a></li><li><a href="#Tables.isrowtable"><code>Tables.isrowtable</code></a></li><li><a href="#Testing-Tables.jl-Implementations">Testing Tables.jl Implementations</a></li></ul></li></ul></li></ul><h2 id="Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)"><a class="docs-heading-anchor" href="#Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)">Using the Interface (i.e. consuming Tables.jl-compatible sources)</a><a id="Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)" title="Permalink"></a></h2><p>We start by discussing <em>usage</em> of the Tables.jl interface functions, since that can help contextualize <em>implementing</em> them for custom table types.</p><p>At a high level, Tables.jl provides two powerful APIs for predictably accessing data from any table-like source:</p><pre><code class="language-julia hljs"># access data of input table `x` row-by-row
# Tables.rows must return a row iterator
rows = Tables.rows(x)

# we can iterate through each row
for row in rows
    # example of getting all values in the row
    # don&#39;t worry, there are other ways to more efficiently process rows
    rowvalues = [Tables.getcolumn(row, col) for col in Tables.columnnames(row)]
end

# access data of input table `x` column-by-column
# Tables.columns returns an object where individul, entire columns can be accessed
columns = Tables.columns(x)

# iterate through each column name in table
for col in Tables.columnnames(columns)
    # retrieve entire column by column name
    # a column is an indexable collection
    # with known length (i.e. supports
    # `length(column)` and `column[i]`)
    column = Tables.getcolumn(columns, col)
end</code></pre><p>So we see two high-level functions here, <a href="#Tables.rows"><code>Tables.rows</code></a>, and <a href="#Tables.columns"><code>Tables.columns</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Tables.rows" href="#Tables.rows"><code>Tables.rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.rows(x) =&gt; Row iterator</code></pre><p>Accesses data of input table source <code>x</code> row-by-row by returning an <a href="#Tables.AbstractRow"><code>AbstractRow</code></a>-compatible iterator. Note that even if the input table source is column-oriented by nature, an efficient generic definition of <code>Tables.rows</code> is defined in Tables.jl to return an iterator of row views into the columns of the input.</p><p>The <a href="#Tables.Schema"><code>Tables.Schema</code></a> of an <code>AbstractRow</code> iterator can be queried via <code>Tables.schema(rows)</code>, which may return <code>nothing</code> if the schema is unknown. Column names can always be queried by calling <code>Tables.columnnames(row)</code> on an individual row, and row values can be accessed by calling <code>Tables.getcolumn(rows, i::Int )</code> or <code>Tables.getcolumn(rows, nm::Symbol)</code> with a column index or name, respectively.</p><p>See also <a href="#Tables.rowtable"><code>rowtable</code></a> and <a href="#Tables.namedtupleiterator"><code>namedtupleiterator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL406-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.columns" href="#Tables.columns"><code>Tables.columns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.columns(x) =&gt; AbstractColumns-compatible object</code></pre><p>Accesses data of input table source <code>x</code> by returning an <a href="#Tables.AbstractColumns"><code>AbstractColumns</code></a>-compatible object, which allows retrieving entire columns by name or index. A retrieved column is a 1-based indexable object that has a known length, i.e. supports <code>length(col)</code> and <code>col[i]</code> for any <code>i = 1:length(col)</code>. Note that even if the input table source is row-oriented by nature, an efficient generic definition of <code>Tables.columns</code> is defined in Tables.jl to build a <code>AbstractColumns</code>- compatible object object from the input rows.</p><p>The <a href="#Tables.Schema"><code>Tables.Schema</code></a> of a <code>AbstractColumns</code> object can be queried via <code>Tables.schema(columns)</code>, which may return <code>nothing</code> if the schema is unknown. Column names can always be queried by calling <code>Tables.columnnames(columns)</code>, and individual columns can be accessed by calling <code>Tables.getcolumn(columns, i::Int )</code> or <code>Tables.getcolumn(columns, nm::Symbol)</code> with a column index or name, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL387-L403">source</a></section></article><p>Given these two powerful data access methods, let&#39;s walk through real, albeit somewhat simplified versions of how packages actually use these methods.</p><h3 id="Tables.rows-usage"><a class="docs-heading-anchor" href="#Tables.rows-usage"><code>Tables.rows</code> usage</a><a id="Tables.rows-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.rows-usage" title="Permalink"></a></h3><p>First up, let&#39;s take a look at the <a href="https://github.com/JuliaDatabases/SQLite.jl">SQLite.jl</a> package and how it uses the Tables.jl interface to allow loading of generic table-like data into a sqlite relational table. Here&#39;s the code:</p><pre><code class="language-julia hljs">function load!(table, db::SQLite.DB, tablename)
    # get input table rows
    rows = Tables.rows(table)
    # query for schema of data
    sch = Tables.schema(rows)
    # create table using tablename and schema from input table
    createtable!(db, tablename, sch)
    # build insert statement
    params = chop(repeat(&quot;?,&quot;, length(sch.names)))
    stmt = Stmt(db, &quot;INSERT INTO $tablename VALUES ($params)&quot;)
    # start a transaction for inserting rows
    transaction(db) do
        # iterate over rows in the input table
        for row in rows
            # Tables.jl provides a utility function
            # Tables.eachcolumn, which allows efficiently
            # applying a function to each column value in a row
            # it&#39;s called with a schema and row, and applies
            # a user-provided function to the column value `val`, index `i`
            # and column name `nm`. Here, we bind the row values
            # to our parameterized SQL INSERT statement and then
            # call `sqlite3_step` to execute the INSERT statement.
            Tables.eachcolumn(sch, row) do val, i, nm
                bind!(stmt, i, val)
            end
            sqlite3_step(stmt.handle)
            sqlite3_reset(stmt.handle)
        end
    end
    return
end</code></pre><p>This is pretty straightforward usage: it calls <a href="#Tables.rows"><code>Tables.rows</code></a> on the input table source, and since we need the schema to setup the database table, we query it via <a href="#Tables.schema"><code>Tables.schema</code></a>. We then iterate the rows in our table via <code>for row in rows</code>, and use the convenient <a href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> to efficiently apply a function to each value in the row. Note that we didn&#39;t call <a href="@ref"><code>Tables.columnnames</code></a> or <a href="@ref"><code>Tables.getcolumn</code></a> at all, since they&#39;re utilized by <a href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> itself. <a href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> is optimized to provide type-stable, and even constant-propagation of column index, name, and type in some cases to allow for efficient consumption of row values.</p><p>One wrinkle to consider is the &quot;unknown schema&quot; case; i.e. what if our <a href="#Tables.schema"><code>Tables.schema</code></a> call had returned <code>nothing</code> (this can be the case for exotic table sources like lazily mapped transformations over rows in a table):</p><pre><code class="language-julia hljs">function load!(sch::Nothing, rows, db::SQLite.DB, tablename)
    # sch is nothing === unknown schema
    # start iteration on input table rows
    state = iterate(rows)
    state === nothing &amp;&amp; return
    row, st = state
    # query column names of first row
    names = Tables.columnnames(row)
    # partially construct Tables.Schema by at least passing
    # the column names to it
    sch = Tables.Schema(names, nothing)
    # create table if needed
    createtable!(db, tablename, sch)
    # build insert statement
    params = chop(repeat(&quot;?,&quot;, length(names)))
    stmt = Stmt(db, &quot;INSERT INTO $nm VALUES ($params)&quot;)
    # start a transaction for inserting rows
    transaction(db) do
        while true
            # just like before, we can still use `Tables.eachcolumn`
            # even with our partially constructed Tables.Schema
            # to apply a function to each value in the row
            Tables.eachcolumn(sch, row) do val, i, nm
                bind!(stmt, i, val)
            end
            sqlite3_step(stmt.handle)
            sqlite3_reset(stmt.handle)
            # keep iterating rows until we finish
            state = iterate(rows, st)
            state === nothing &amp;&amp; break
            row, st = state
        end
    end
    return name
end</code></pre><p>The strategy taken here is to start iterating the input source, and using the first row as a guide, we make a <a href="#Tables.Schema"><code>Tables.Schema</code></a> object with just the column names, which we can then still pass to <a href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> to apply our <code>bind!</code> function to each row value.</p><h3 id="Tables.columns-usage"><a class="docs-heading-anchor" href="#Tables.columns-usage"><code>Tables.columns</code> usage</a><a id="Tables.columns-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.columns-usage" title="Permalink"></a></h3><p>Ok, now let&#39;s take a look at a case utlizing <a href="#Tables.columns"><code>Tables.columns</code></a>. The following code is taken from the <a href="https://github.com/JuliaData/DataFrames.jl/blob/master/src/other/tables.jl">DataFrames.jl</a> Tables.jl implementation:</p><pre><code class="language-julia hljs">getvector(x::AbstractVector) = x
getvector(x) = collect(x)

# note that copycols is ignored in this definition (Tables.CopiedColumns implies copies have already been made)
fromcolumns(x::Tables.CopiedColumns, names; copycols::Bool=true) =
    DataFrame(AbstractVector[getvector(Tables.getcolumn(x, nm) for nm in names],
              Index(names),
              copycols=false)
fromcolumns(x; copycols::Bool=true) =
    DataFrame(AbstractVector[getvector(Tables.getcolumn(x, nm) for nm in names],
              Index(names),
              copycols=copycols)

function DataFrame(x; copycols::Bool=true)
    # get columns from input table source
    cols = Tables.columns(x)
    # get column names as Vector{Symbol}, which is required
    # by core DataFrame constructor
    names = collect(Symbol, Tables.columnnames(cols))
    return fromcolumns(cols, names; copycols=copycols)
end</code></pre><p>So here we have a generic <code>DataFrame</code> constructor that takes a single, untyped argument, calls <a href="#Tables.columns"><code>Tables.columns</code></a> on it, then <a href="@ref"><code>Tables.columnnames</code></a> to get the column names. It then passes the <a href="#Tables.AbstractColumns"><code>Tables.AbstractColumns</code></a>-compatible object to an internal function <code>fromcolumns</code>, which dispatches on a special kind of <code>Tables.AbstractColumns</code> object called a <a href="@ref"><code>Tables.CopiedColumns</code></a>, which wraps any <code>Tables.AbstractColumns</code>-compatible object that has already had copies of its columns made, and are thus safe for the columns-consumer to assume ownership of (this is because DataFrames.jl, by default makes copies of all columns upon construction). In both cases, individual columns are collected in <code>Vector{AbstractVector}</code>s by calling <code>Tables.getcolumn(x, nm)</code> for each column name. A final note is the call to <code>getvector</code> on each column, which ensures each column is materialized as an <code>AbstractVector</code>, as is required by the DataFrame constructor.</p><p>Note in both the rows and columns usages, we didn&#39;t need to worry about the natural orientation of the input data; we just called <a href="#Tables.rows"><code>Tables.rows</code></a> or <a href="#Tables.columns"><code>Tables.columns</code></a> as was most natural for the table-specific use-case, knowing that it will Just Work™️.</p><h3 id="Tables.jl-Utilities"><a class="docs-heading-anchor" href="#Tables.jl-Utilities">Tables.jl Utilities</a><a id="Tables.jl-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.jl-Utilities" title="Permalink"></a></h3><p>Before moving on to <em>implementing</em> the Tables.jl interfaces, we take a quick break to highlight some useful utility functions provided by Tables.jl:</p><article class="docstring"><header><a class="docstring-binding" id="Tables.Schema" href="#Tables.Schema"><code>Tables.Schema</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tables.Schema(names, types)</code></pre><p>Create a <code>Tables.Schema</code> object that holds the column names and types for an <code>AbstractRow</code> iterator returned from <code>Tables.rows</code> or an <code>AbstractColumns</code> object returned from <code>Tables.columns</code>. <code>Tables.Schema</code> is dual-purposed: provide an easy interface for users to query these properties, as well as provide a convenient &quot;structural&quot; type for code generation.</p><p>To get a table&#39;s schema, one can call <code>Tables.schema</code> on the result of <code>Tables.rows</code> or <code>Tables.columns</code>, but also note that a table may return <code>nothing</code>, indicating that its column names and/or column element types are unknown (usually not inferrable). This is similar to the <code>Base.EltypeUnknown()</code> trait for iterators when <code>Base.IteratorEltype</code> is called. Users should account for the <code>Tables.schema(tbl) =&gt; nothing</code> case by using the properties of the results of <code>Tables.rows(x)</code> and <code>Tables.columns(x)</code> directly.</p><p>To access the names, one can simply call <code>sch.names</code> to return a collection of Symbols (<code>Tuple</code> or <code>Vector</code>). To access column element types, one can similarly call <code>sch.types</code>, which will return a collection of types (like <code>(Int64, Float64, String)</code>).</p><p>The actual type definition is</p><pre><code class="language-julia hljs">struct Schema{names, types}
    storednames::Union{Nothing, Vector{Symbol}}
    storedtypes::Union{Nothing, Vector{Type}}
end</code></pre><p>Where <code>names</code> is a tuple of <code>Symbol</code>s or <code>nothing</code>, and <code>types</code> is a tuple <em>type</em> of types (like <code>Tuple{Int64, Float64, String}</code>) or <code>nothing</code>. Encoding the names &amp; types as type parameters allows convenient use of the type in generated functions and other optimization use-cases, but users should note that when <code>names</code> and/or <code>types</code> are the <code>nothing</code> value, the names and/or types are stored in the <code>storednames</code> and <code>storedtypes</code> fields. This is to account for extremely wide tables with columns in the 10s of thousands where encoding the names/types as type parameters becomes prohibitive to the compiler. So while optimizations can be written on the typed <code>names</code>/<code>types</code> type parameters, users should also consider handling the extremely wide tables by specializing on <code>Tables.Schema{nothing, nothing}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL425-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.schema" href="#Tables.schema"><code>Tables.schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.schema(x) =&gt; Union{Nothing, Tables.Schema}</code></pre><p>Attempt to retrieve the schema of the object returned by <code>Tables.rows</code> or <code>Tables.columns</code>. If the <code>AbstractRow</code> iterator or <code>AbstractColumns</code> object can&#39;t determine its schema, <code>nothing</code> will be returned. Otherwise, a <code>Tables.Schema</code> object is returned, with the column names and types available for use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL357-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.subset" href="#Tables.subset"><code>Tables.subset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.subset(x, inds; view=nothing)</code></pre><p>Return one or more rows from table <code>x</code> according to the position(s) specified by <code>inds</code>:</p><ul><li>If <code>inds</code> is a single non-boolean integer return a row object.</li><li>If <code>inds</code> is a vector of non-boolean integers, a vector of booleans, or a <code>:</code>, return a subset of the original table according to the indices. In this case, the returned type is not necessarily the same as the original table type.</li></ul><p>If other types of <code>inds</code> are passed than specified above the behavior is undefined.</p><p>The <code>view</code> argument influences whether the returned object is a view of the original table or an independent copy:</p><ul><li>If <code>view=nothing</code> (the default) then the implementation for a specific table type is free to decide  whether to return a copy or a view.</li><li>If <code>view=true</code> then a view is returned and if <code>view=false</code> a copy is returned. This applies both to returning a row or a table.</li></ul><p>Any specialized implementation of <code>subset</code> must support the <code>view=nothing</code> argument. Support for <code>view=true</code> or <code>view=false</code> is optional (i.e. implementations might error on them if they are not supported).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL576-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.partitions" href="#Tables.partitions"><code>Tables.partitions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.partitions(x)</code></pre><p>Request a &quot;table&quot; iterator from <code>x</code>. Each iterated element must be a &quot;table&quot; in the sense that one may call <code>Tables.rows</code> or <code>Tables.columns</code> to get a row-iterator or collection of columns. All iterated elements <em>must</em> have identical schema, so that users may call <code>Tables.schema(first_element)</code> on the first iterated element and know that each subsequent iteration will match the same schema. The default definition is:</p><pre><code class="language-julia hljs">Tables.partitions(x) = (x,)</code></pre><p>So that any input is assumed to be a single &quot;table&quot;. This means users should feel free to call <code>Tables.partitions</code> anywhere they&#39;re currently calling <code>Tables.columns</code> or <code>Tables.rows</code>, and get back an iterator of those instead. In other words, &quot;sink&quot; functions can use <code>Tables.partitions</code> whether or not the user passes a partionable table, since the default is to treat a single input as a single, non-partitioned table.</p><p><code>Tables.partitioner(itr)</code>(@ref) is a convenience wrapper to provide table partitions from any table iterator; this allows for easy wrapping of a <code>Vector</code> or iterator of tables as valid partitions, since by default, they&#39;d be treated as a single table.</p><p>A 2nd convenience method is provided with the defintion:</p><pre><code class="language-julia hljs">Tables.partitions(x...) = x</code></pre><p>That allows passing vararg tables and they&#39;ll be treated as separate partitions. Sink functions may allow vararg table inputs and can &quot;splat them through&quot; to <code>partitions</code>.</p><p>For convenience, <code>Tables.partitions(Iterators.partition(...))</code> is defined for cases where user-controlled partitioning is desired over an applicable input (an input iterator).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL507-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.partitioner" href="#Tables.partitioner"><code>Tables.partitioner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.partitioner(f, itr)
Tables.partitioner(x)</code></pre><p>Convenience methods to generate table iterators. The first method takes a &quot;materializer&quot; function <code>f</code> and an iterator <code>itr</code>, and will call <code>Tables.LazyTable(f, x) for x in itr</code> for each iteration. This allows delaying table materialization until <code>Tables.columns</code> or <code>Tables.rows</code> are called on the <code>LazyTable</code> object (which will call <code>f(x)</code>). This allows a common desired pattern of materializing and processing a table on a remote process or thread, like:</p><pre><code class="language-julia hljs">for tbl in Tables.partitions(Tables.partitioner(CSV.File, list_of_csv_files))
    Threads.@spawn begin
        cols = Tables.columns(tbl)
        # do stuff with cols
    end
end</code></pre><p>The second method is provided because the default behavior of <code>Tables.partition(x)</code> is to treat <code>x</code> as a single, non-partitioned table. This method allows users to easily wrap a <code>Vector</code> or generator of tables as table partitions to pass to sink functions able to utilize <code>Tables.partitions</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL627-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.rowtable" href="#Tables.rowtable"><code>Tables.rowtable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.rowtable(x) =&gt; Vector{NamedTuple}</code></pre><p>Take any input table source, and produce a <code>Vector</code> of <code>NamedTuple</code>s, also known as a &quot;row table&quot;. A &quot;row table&quot; is a kind of default table type of sorts, since it satisfies the Tables.jl row interface naturally, i.e. a <code>Vector</code> naturally iterates its elements, and <code>NamedTuple</code> satisifes the <code>AbstractRow</code> interface by default (allows indexing value by index, name, and getting all names).</p><p>For a lazy iterator over rows see <a href="#Tables.rows"><code>rows</code></a> and <a href="#Tables.namedtupleiterator"><code>namedtupleiterator</code></a>.</p><p>Not for use with extremely wide tables with # of columns &gt; 67K; current fundamental compiler limits prevent constructing <code>NamedTuple</code>s that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/namedtuples.jl#LL87-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.columntable" href="#Tables.columntable"><code>Tables.columntable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.columntable(x) =&gt; NamedTuple of Vectors</code></pre><p>Takes any input table source <code>x</code> and returns a <code>NamedTuple</code> of <code>Vector</code>s, also known as a &quot;column table&quot;. A &quot;column table&quot; is a kind of default table type of sorts, since it satisfies the Tables.jl column interface naturally.</p><p>Not for use with extremely wide tables with # of columns &gt; 67K; current fundamental compiler limits prevent constructing <code>NamedTuple</code>s that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/namedtuples.jl#LL141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.dictrowtable" href="#Tables.dictrowtable"><code>Tables.dictrowtable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.dictrowtable(x) =&gt; Tables.DictRowTable</code></pre><p>Take any Tables.jl-compatible source <code>x</code> and return a <code>DictRowTable</code>, which can be thought of as a <code>Vector</code> of <code>OrderedDict</code> rows mapping column names as <code>Symbol</code>s to values. The order of the input table columns is preserved via the <code>Tables.schema(::DictRowTable)</code>.</p><p>For &quot;schema-less&quot; input tables, <code>dictrowtable</code> employs a &quot;column unioning&quot; behavior, as opposed to inferring the schema from the first row like <code>Tables.columns</code>. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value <code>missing</code>, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it&#39;s recommended to use only when the union behavior is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/dicts.jl#LL137-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.dictcolumntable" href="#Tables.dictcolumntable"><code>Tables.dictcolumntable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.dictcolumntable(x) =&gt; Tables.DictColumnTable</code></pre><p>Take any Tables.jl-compatible source <code>x</code> and return a <code>DictColumnTable</code>, which can be thought of as a <code>OrderedDict</code> mapping column names as <code>Symbol</code>s to <code>AbstractVector</code>s. The order of the input table columns is preserved via the <code>Tables.schema(::DictColumnTable)</code>.</p><p>For &quot;schema-less&quot; input tables, <code>dictcolumntable</code> employs a &quot;column unioning&quot; behavior, as opposed to inferring the schema from the first row like <code>Tables.columns</code>. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value <code>missing</code>, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it&#39;s recommended to use only when needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/dicts.jl#LL7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.namedtupleiterator" href="#Tables.namedtupleiterator"><code>Tables.namedtupleiterator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.namedtupleiterator(x)</code></pre><p>Pass any table input source and return a <code>NamedTuple</code> iterator</p><p>See also <a href="#Tables.rows"><code>rows</code></a> and <a href="#Tables.rowtable"><code>rowtable</code></a>.</p><p>Not for use with extremely wide tables with # of columns &gt; 67K; current fundamental compiler limits prevent constructing <code>NamedTuple</code>s that large.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/namedtuples.jl#LL14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.datavaluerows" href="#Tables.datavaluerows"><code>Tables.datavaluerows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.datavaluerows(x) =&gt; NamedTuple iterator</code></pre><p>Takes any table input <code>x</code> and returns a <code>NamedTuple</code> iterator that will replace missing values with <code>DataValue</code>-wrapped values; this allows any table type to satisfy the TableTraits.jl  Queryverse integration interface by defining: </p><pre><code class="nohighlight hljs">IteratorInterfaceExtensions.getiterator(x::MyTable) = Tables.datavaluerows(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/tofromdatavalues.jl#LL83-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.nondatavaluerows" href="#Tables.nondatavaluerows"><code>Tables.nondatavaluerows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.nondatavaluerows(x)</code></pre><p>Takes any Queryverse-compatible <code>NamedTuple</code> iterator source and  converts to a Tables.jl-compatible <code>AbstractRow</code> iterator. Will automatically unwrap any <code>DataValue</code>s, replacing <code>NA</code> with <code>missing</code>. Useful for translating Query.jl results back to non-<code>DataValue</code>-based tables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/tofromdatavalues.jl#LL16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.table" href="#Tables.table"><code>Tables.table</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.table(m::AbstractVecOrMat; [header])</code></pre><p>Wrap an <code>AbstractVecOrMat</code> (<code>Matrix</code>, <code>Vector</code>, <code>Adjoint</code>, etc.) in a <code>MatrixTable</code>, which satisfies the Tables.jl interface.  (An <code>AbstractVector</code> is treated as a 1-column matrix.) This allows accessing the matrix via <code>Tables.rows</code> and <code>Tables.columns</code>. An optional keyword argument iterator <code>header</code> can be passed which will be converted to a <code>Vector{Symbol}</code> to be used as the column names. Note that no copy of the <code>AbstractVecOrMat</code> is made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/matrix.jl#LL54-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.matrix" href="#Tables.matrix"><code>Tables.matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.matrix(table; transpose::Bool=false)</code></pre><p>Materialize any table source input as a new <code>Matrix</code> or in the case of a <code>MatrixTable</code> return the originally wrapped matrix. If the table column element types are not homogenous, they will be promoted to a common type in the materialized <code>Matrix</code>. Note that column names are ignored in the conversion. By default, input table columns will be materialized as corresponding matrix columns; passing <code>transpose=true</code> will transpose the input with input columns as matrix rows or in the case of a <code>MatrixTable</code> apply <code>permutedims</code> to the originally wrapped matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/matrix.jl#LL72-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.eachcolumn" href="#Tables.eachcolumn"><code>Tables.eachcolumn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.eachcolumn(f, sch::Tables.Schema{names, types}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})
Tables.eachcolumn(f, sch::Tables.Schema{names, nothing}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})</code></pre><p>Takes a function <code>f</code>, table schema <code>sch</code>, <code>x</code>, which is an object that satisfies the <code>AbstractRow</code> or <code>AbstractColumns</code> interfaces; it generates calls to get the value for each column (<code>Tables.getcolumn(x, nm)</code>) and then calls <code>f(val, index, name)</code>, where <code>f</code> is the user-provided function, <code>val</code> is the column value (<code>AbstractRow</code>) or entire column (<code>AbstractColumns</code>), <code>index</code> is the column index as an <code>Int</code>, and <code>name</code> is the column name as a <code>Symbol</code>.</p><p>An example using <code>Tables.eachcolumn</code> is:</p><pre><code class="language-julia hljs">rows = Tables.rows(tbl)
sch = Tables.schema(rows)
if sch === nothing
    state = iterate(rows)
    state === nothing &amp;&amp; return
    row, st = state
    sch = Tables.schema(Tables.columnnames(row), nothing)
    while state !== nothing
        Tables.eachcolumn(sch, row) do val, i, nm
            bind!(stmt, i, val)
        end
        state = iterate(rows, st)
        state === nothing &amp;&amp; return
        row, st = state
    end
else
    for row in rows
        Tables.eachcolumn(sch, row) do val, i, nm
            bind!(stmt, i, val)
        end
    end
end</code></pre><p>Note in this example we account for the input table potentially returning <code>nothing</code> from <code>Tables.schema(rows)</code>; in that case, we start iterating the rows, and build a partial schema using the column names from the first row <code>sch = Tables.schema(Tables.columnnames(row), nothing)</code>, which is valid to pass to <code>Tables.eachcolumn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/utils.jl#LL22-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.materializer" href="#Tables.materializer"><code>Tables.materializer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.materializer(x) =&gt; Callable</code></pre><p>For a table input, return the &quot;sink&quot; function or &quot;materializing&quot; function that can take a Tables.jl-compatible table input and make an instance of the table type. This enables &quot;transform&quot; workflows that take table inputs, apply transformations, potentially converting the table to a different form, and end with producing a table of the same type as the original input. The default materializer is <code>Tables.columntable</code>, which converts any table input into a <code>NamedTuple</code> of <code>Vector</code>s.</p><p>It is recommended that for users implementing <code>MyType</code>, they define only <code>materializer(::Type{&lt;:MyType})</code>. <code>materializer(::MyType)</code> will then automatically delegate to this method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL368-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.columnindex" href="#Tables.columnindex"><code>Tables.columnindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.columnindex(table, name::Symbol)</code></pre><p>Return the column index (1-based) of a column by <code>name</code> in a table with a known schema; returns 0 if <code>name</code> doesn&#39;t exist in table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL685-L689">source</a></section><section><div><p>given names and a Symbol <code>name</code>, compute the index (1-based) of the name in names</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.columntype" href="#Tables.columntype"><code>Tables.columntype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.columntype(table, name::Symbol)</code></pre><p>Return the column element type of a column by <code>name</code> in a table with a known schema; returns Union{} if <code>name</code> doesn&#39;t exist in table</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL692-L696">source</a></section><section><div><p>given tuple type and a Symbol <code>name</code>, compute the type of the name in the tuples types</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.rowmerge" href="#Tables.rowmerge"><code>Tables.rowmerge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rowmerge(row, other_rows...)
rowmerge(row; fields_to_merge...)</code></pre><p>Return a <code>NamedTuple</code> by merging <code>row</code> (an <code>AbstractRow</code>-compliant value) with <code>other_rows</code> (one or more <code>AbstractRow</code>-compliant values) via <code>Base.merge</code>. This function is similar to <code>Base.merge(::NamedTuple, ::NamedTuple...)</code>, but accepts <code>AbstractRow</code>-compliant values instead of <code>NamedTuple</code>s.</p><p>A convenience method <code>rowmerge(row; fields_to_merge...) = rowmerge(row, fields_to_merge)</code> is defined that enables the <code>fields_to_merge</code> to be specified as keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/utils.jl#LL145-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.Row" href="#Tables.Row"><code>Tables.Row</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tables.Row(row)</code></pre><p>Convenience type to wrap any <code>AbstractRow</code> interface object in a dedicated struct to provide useful default behaviors (allows any <code>AbstractRow</code> to be used like a <code>NamedTuple</code>):</p><ul><li>Indexing interface defined; i.e. <code>row[i]</code> will return the column value at index <code>i</code>, <code>row[nm]</code> will return column value for column name <code>nm</code></li><li>Property access interface defined; i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column value in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving column values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL238-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Tables.Columns" href="#Tables.Columns"><code>Tables.Columns</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tables.Columns(tbl)</code></pre><p>Convenience type that calls <code>Tables.columns</code> on an input <code>tbl</code> and wraps the resulting <code>AbstractColumns</code> interface object in a dedicated struct to provide useful default behaviors (allows any <code>AbstractColumns</code> to be used like a <code>NamedTuple</code> of <code>Vectors</code>):</p><ul><li>Indexing interface defined; i.e. <code>row[i]</code> will return the column at index <code>i</code>, <code>row[nm]</code> will return column for column name <code>nm</code></li><li>Property access interface defined; i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving columns</li></ul><p>Note that <code>Tables.Columns</code> calls <code>Tables.columns</code> internally on the provided table argument. <code>Tables.Columns</code> can be used for dispatch if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL254-L266">source</a></section></article><h2 id="Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)"><a class="docs-heading-anchor" href="#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)">Implementing the Interface (i.e. becoming a Tables.jl source)</a><a id="Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)" title="Permalink"></a></h2><p>Now that we&#39;ve seen how one <em>uses</em> the Tables.jl interface, let&#39;s walk-through how to implement it; i.e. how can I make my custom type valid for Tables.jl consumers?</p><p>For a type <code>MyTable</code>, the interface to becoming a proper table is straightforward:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.istable(::Type{MyTable})</code></td><td style="text-align: right"></td><td style="text-align: right">Declare that your table type implements the interface</td></tr><tr><td style="text-align: right"><strong>One of:</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.rowaccess(::Type{MyTable})</code></td><td style="text-align: right"></td><td style="text-align: right">Declare that your table type defines a <code>Tables.rows(::MyTable)</code> method</td></tr><tr><td style="text-align: right"><code>Tables.rows(x::MyTable)</code></td><td style="text-align: right"></td><td style="text-align: right">Return an <code>Tables.AbstractRow</code>-compatible iterator from your table</td></tr><tr><td style="text-align: right"><strong>Or:</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.columnaccess(::Type{MyTable})</code></td><td style="text-align: right"></td><td style="text-align: right">Declare that your table type defines a <code>Tables.columns(::MyTable)</code> method</td></tr><tr><td style="text-align: right"><code>Tables.columns(x::MyTable)</code></td><td style="text-align: right"></td><td style="text-align: right">Return an <code>Tables.AbstractColumns</code>-compatible object from your table</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.schema(x::MyTable)</code></td><td style="text-align: right"><code>Tables.schema(x) = nothing</code></td><td style="text-align: right">Return a <a href="#Tables.Schema"><code>Tables.Schema</code></a> object from your <code>Tables.AbstractRow</code> iterator or <code>Tables.AbstractColumns</code> object; or <code>nothing</code> for unknown schema</td></tr><tr><td style="text-align: right"><code>Tables.materializer(::Type{MyTable})</code></td><td style="text-align: right"><code>Tables.columntable</code></td><td style="text-align: right">Declare a &quot;materializer&quot; sink function for your table type that can construct an instance of your type from any Tables.jl input</td></tr><tr><td style="text-align: right"><code>Tables.getrows(x::MyTable, inds; view)</code></td><td style="text-align: right"></td><td style="text-align: right">Return a row or a sub-table of the original table</td></tr></table><p>Based on whether your table type has defined <code>Tables.rows</code> or <code>Tables.columns</code>, you then ensure that the <code>Tables.AbstractRow</code> iterator or <code>Tables.AbstractColumns</code> object satisfies the respective interface.</p><p>As an additional source of documentation, see <a href="https://discourse.julialang.org/t/struggling-to-implement-tables-jl-interface-for-vector-mystruct/42318/7?u=quinnj">this discourse post</a> outlining in detail a walk-through of making a row-oriented table.</p><h3 id="Tables.AbstractRow"><a class="docs-heading-anchor" href="#Tables.AbstractRow"><code>Tables.AbstractRow</code></a><a id="Tables.AbstractRow-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.AbstractRow" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Tables.AbstractRow" href="#Tables.AbstractRow"><code>Tables.AbstractRow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tables.AbstractRow</code></pre><p>Abstract interface type representing the expected <code>eltype</code> of the iterator returned from <code>Tables.rows(table)</code>. <code>Tables.rows</code> must return an iterator of elements that satisfy the <code>Tables.AbstractRow</code> interface. While <code>Tables.AbstractRow</code> is an abstract type that custom &quot;row&quot; types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects <strong>are not required</strong> to subtype, but only implement the required interface methods.</p><p>Interface definition:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, i::Int)</code></td><td style="text-align: right">getfield(row, i)</td><td style="text-align: right">Retrieve a column value by index</td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, nm::Symbol)</code></td><td style="text-align: right">getproperty(row, nm)</td><td style="text-align: right">Retrieve a column value by name</td></tr><tr><td style="text-align: right"><code>Tables.columnnames(row)</code></td><td style="text-align: right">propertynames(row)</td><td style="text-align: right">Return column names for a row as an indexable collection</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol)</code></td><td style="text-align: right">Tables.getcolumn(row, nm)</td><td style="text-align: right">Given a column element type <code>T</code>, index <code>i</code>, and column name <code>nm</code>, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency.</td></tr></table><p>Note that subtypes of <code>Tables.AbstractRow</code> <strong>must</strong> overload all required methods listed above instead of relying on these methods&#39; default definitions.</p><p>While custom row types aren&#39;t required to subtype <code>Tables.AbstractRow</code>, benefits of doing so include:</p><ul><li>Indexing interface defined (using <code>getcolumn</code>); i.e. <code>row[i]</code> will return the column value at index <code>i</code></li><li>Property access interface defined (using <code>columnnames</code> and <code>getcolumn</code>); i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column value in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving column values</li><li>A default <code>show</code> method</li></ul><p>This allows the custom row type to behave as close as possible to a builtin <code>NamedTuple</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL49-L79">source</a></section></article><h3 id="Tables.AbstractColumns"><a class="docs-heading-anchor" href="#Tables.AbstractColumns"><code>Tables.AbstractColumns</code></a><a id="Tables.AbstractColumns-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.AbstractColumns" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Tables.AbstractColumns" href="#Tables.AbstractColumns"><code>Tables.AbstractColumns</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Tables.AbstractColumns</code></pre><p>An interface type defined as an ordered set of columns that support retrieval of individual columns by name or index. A retrieved column must be a 1-based indexable collection with known length, i.e. an object that supports <code>length(col)</code> and <code>col[i]</code> for any <code>i = 1:length(col)</code>. <code>Tables.columns</code> must return an object that satisfies the <code>Tables.AbstractColumns</code> interface. While <code>Tables.AbstractColumns</code> is an abstract type that custom &quot;columns&quot; types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects <strong>are not required</strong> to subtype, but only implement the required interface methods.</p><p>Interface definition:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, i::Int)</code></td><td style="text-align: right">getfield(table, i)</td><td style="text-align: right">Retrieve a column by index</td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, nm::Symbol)</code></td><td style="text-align: right">getproperty(table, nm)</td><td style="text-align: right">Retrieve a column by name</td></tr><tr><td style="text-align: right"><code>Tables.columnnames(table)</code></td><td style="text-align: right">propertynames(table)</td><td style="text-align: right">Return column names for a table as an indexable collection</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol)</code></td><td style="text-align: right">Tables.getcolumn(table, nm)</td><td style="text-align: right">Given a column eltype <code>T</code>, index <code>i</code>, and column name <code>nm</code>, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency.</td></tr></table><p>Note that subtypes of <code>Tables.AbstractColumns</code> <strong>must</strong> overload all required methods listed above instead of relying on these methods&#39; default definitions.</p><p>While types aren&#39;t required to subtype <code>Tables.AbstractColumns</code>, benefits of doing so include:</p><ul><li>Indexing interface defined (using <code>getcolumn</code>); i.e. <code>tbl[i]</code> will retrieve the column at index <code>i</code></li><li>Property access interface defined (using <code>columnnames</code> and <code>getcolumn</code>); i.e. <code>tbl.col1</code> will retrieve column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for col in table</code> will iterate each column in the table</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving columns</li><li>A default <code>show</code> method</li></ul><p>This allows a custom table type to behave as close as possible to a builtin <code>NamedTuple</code> of vectors object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL13-L46">source</a></section></article><h3 id="Implementation-Example"><a class="docs-heading-anchor" href="#Implementation-Example">Implementation Example</a><a id="Implementation-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Example" title="Permalink"></a></h3><p>As an extended example, let&#39;s take a look at some code defined in Tables.jl for treating <code>AbstractVecOrMat</code>s as tables.</p><p>First, we define a special <code>MatrixTable</code> type that will wrap an <code>AbstractVecOrMat</code>, and allow easy overloading for the Tables.jl interface.</p><pre><code class="language-julia hljs">struct MatrixTable{T &lt;: AbstractVecOrMat} &lt;: Tables.AbstractColumns
    names::Vector{Symbol}
    lookup::Dict{Symbol, Int}
    matrix::T
end
# declare that MatrixTable is a table
Tables.istable(::Type{&lt;:MatrixTable}) = true
# getter methods to avoid getproperty clash
names(m::MatrixTable) = getfield(m, :names)
matrix(m::MatrixTable) = getfield(m, :matrix)
lookup(m::MatrixTable) = getfield(m, :lookup)
# schema is column names and types
Tables.schema(m::MatrixTable{T}) where {T} = Tables.Schema(names(m), fill(eltype(T), size(mat(m), 2)))</code></pre><p>Here we defined <code>Tables.istable</code> for all <code>MatrixTable</code> types, signaling that they implement the Tables.jl interfaces. We also defined <a href="#Tables.schema"><code>Tables.schema</code></a> by pulling the column names out that we stored, and since <code>AbstractVecOrMat</code> have a single <code>eltype</code>, we repeat it for each column (the call to <code>fill</code>). Note that defining <a href="#Tables.schema"><code>Tables.schema</code></a> is optional on tables; by default, <code>nothing</code> is returned and Tables.jl consumers should account for both known and unknown schema cases. Returning a schema when possible allows consumers to have certain optimizations when they can know the types of all columns upfront (and if the # of columns isn&#39;t too large) to generate more efficient code.</p><p>Now, in this example, we&#39;re actually going to have <code>MatrixTable</code> implement <em>both</em> <code>Tables.rows</code> and <code>Tables.columns</code> methods itself, i.e. it&#39;s going to return itself from those functions, so here&#39;s first how we make our <code>MatrixTable</code> a valid <code>Tables.AbstractColumns</code> object:</p><pre><code class="language-julia hljs"># column interface
Tables.columnaccess(::Type{&lt;:MatrixTable}) = true
Tables.columns(m::MatrixTable) = m
# required Tables.AbstractColumns object methods
Tables.getcolumn(m::MatrixTable, ::Type{T}, col::Int, nm::Symbol) where {T} = matrix(m)[:, col]
Tables.getcolumn(m::MatrixTable, nm::Symbol) = matrix(m)[:, lookup(m)[nm]]
Tables.getcolumn(m::MatrixTable, i::Int) = matrix(m)[:, i]
Tables.columnnames(m::MatrixTable) = names(m)</code></pre><p>We define <code>columnaccess</code> for our type, then <code>columns</code> just returns the <code>MatrixTable</code> itself, and then we define the three <code>getcolumn</code> methods and <code>columnnames</code>. Note the use of a <code>lookup</code> <code>Dict</code> that maps column name to column index so we can figure out which column to return from the matrix. We&#39;re also storing the column names in our <code>names</code> field so the <code>columnnames</code> implementation is trivial. And that&#39;s it! Literally! It can now be written out to a csv file, stored in a sqlite or other database, converted to DataFrame or JuliaDB table, etc. Pretty fun.</p><p>And now for the <code>Tables.rows</code> implementation:</p><pre><code class="language-julia hljs"># declare that any MatrixTable defines its own `Tables.rows` method
rowaccess(::Type{&lt;:MatrixTable}) = true
# just return itself, which means MatrixTable must iterate `Tables.AbstractRow`-compatible objects
rows(m::MatrixTable) = m
# the iteration interface, at a minimum, requires `eltype`, `length`, and `iterate`
# for `MatrixTable` `eltype`, we&#39;re going to provide a custom row type
Base.eltype(m::MatrixTable{T}) where {T} = MatrixRow{T}
Base.length(m::MatrixTable) = size(matrix(m), 1)

Base.iterate(m::MatrixTable, st=1) = st &gt; length(m) ? nothing : (MatrixRow(st, m), st + 1)

# a custom row type; acts as a &quot;view&quot; into a row of an AbstractVecOrMat
struct MatrixRow{T} &lt;: Tables.AbstractRow
    row::Int
    source::MatrixTable{T}
end
# required `Tables.AbstractRow` interface methods (same as for `Tables.AbstractColumns` object before)
# but this time, on our custom row type
getcolumn(m::MatrixRow, ::Type, col::Int, nm::Symbol) =
    getfield(getfield(m, :source), :matrix)[getfield(m, :row), col]
getcolumn(m::MatrixRow, i::Int) =
    getfield(getfield(m, :source), :matrix)[getfield(m, :row), i]
getcolumn(m::MatrixRow, nm::Symbol) =
    getfield(getfield(m, :source), :matrix)[getfield(m, :row), getfield(getfield(m, :source), :lookup)[nm]]
columnnames(m::MatrixRow) = names(getfield(m, :source))</code></pre><p>Here we start by defining <code>Tables.rowaccess</code> and <code>Tables.rows</code>, and then the iteration interface methods, since we declared that a <code>MatrixTable</code> itself is an iterator of <code>Tables.AbstractRow</code>-compatible objects. For <code>eltype</code>, we say that a <code>MatrixTable</code> iterates our own custom row type, <code>MatrixRow</code>. <code>MatrixRow</code> subtypes <code>Tables.AbstractRow</code>, which provides interface implementations for several useful behaviors (indexing, iteration, property-access, etc.); essentially it makes our custom <code>MatrixRow</code> type more convenient to work with.</p><p>Implementing the <code>Tables.AbstractRow</code> interface is straightfoward, and very similar to our implementation of <code>Tables.AbstractColumns</code> previously (i.e. the same methods for <code>getcolumn</code> and <code>columnnames</code>).</p><p>And that&#39;s it. Our <code>MatrixTable</code> type is now a fully fledged, valid Tables.jl source and can be used throughout the ecosystem. Now, this is obviously not a lot of code; but then again, the actual Tables.jl interface implementations tend to be fairly simple, given the other behaviors that are already defined for table types (i.e. table types tend to already have a <code>getcolumn</code> like function defined).</p><h3 id="Tables.isrowtable"><a class="docs-heading-anchor" href="#Tables.isrowtable"><code>Tables.isrowtable</code></a><a id="Tables.isrowtable-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.isrowtable" title="Permalink"></a></h3><p>One option for certain table types is to define <code>Tables.isrowtable</code> to automatically satisfy the Tables.jl interface. This can be convenient for &quot;natural&quot; table types that already iterate rows.</p><article class="docstring"><header><a class="docstring-binding" id="Tables.isrowtable" href="#Tables.isrowtable"><code>Tables.isrowtable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Tables.isrowtable(x) =&gt; Bool</code></pre><p>For convenience, some table objects that are naturally &quot;row oriented&quot; can define <code>Tables.isrowtable(::Type{TableType}) = true</code> to simplify satisfying the Tables.jl interface. Requirements for defining <code>isrowtable</code> include:</p><ul><li><code>Tables.rows(x) === x</code>, i.e. the table object itself is a <code>Row</code> iterator</li><li>If the table object is mutable, it should support:<ul><li><code>push!(x, row)</code>: allow pushing a single row onto table</li><li><code>append!(x, rows)</code>: allow appending set of rows onto table</li></ul></li><li>If table object is mutable and indexable, it should support:<ul><li><code>x[i] = row</code>: allow replacing of a row with another row by index</li></ul></li></ul><p>A table object that defines <code>Tables.isrowtable</code> will have definitions for <code>Tables.istable</code>, <code>Tables.rowaccess</code>, and <code>Tables.rows</code> automatically defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/f2e78dfeeb740d6e55bce518d3097bff5e817deb/src/Tables.jl#LL118-L133">source</a></section></article><h3 id="Testing-Tables.jl-Implementations"><a class="docs-heading-anchor" href="#Testing-Tables.jl-Implementations">Testing Tables.jl Implementations</a><a id="Testing-Tables.jl-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Tables.jl-Implementations" title="Permalink"></a></h3><p>One question that comes up is what the best strategies are for testing a Tables.jl implementation. Continuing with our <code>MatrixTable</code> example, let&#39;s see some useful ways to test that things are working as expected.</p><pre><code class="language-julia hljs">mat = [1 4.0 &quot;7&quot;; 2 5.0 &quot;8&quot;; 3 6.0 &quot;9&quot;]</code></pre><p>First, we define a matrix literal with three columns of various differently typed values.</p><pre><code class="language-julia hljs"># first, create a MatrixTable from our matrix input
mattbl = Tables.table(mat)
# test that the MatrixTable `istable`
@test Tables.istable(typeof(mattbl))
# test that it defines row access
@test Tables.rowaccess(typeof(mattbl))
@test Tables.rows(mattbl) === mattbl
# test that it defines column access
@test Tables.columnaccess(typeof(mattbl))
@test Tables.columns(mattbl) === mattbl
# test that we can access the first &quot;column&quot; of our matrix table by column name
@test mattbl.Column1 == [1,2,3]
# test our `Tables.AbstractColumns` interface methods
@test Tables.getcolumn(mattbl, :Column1) == [1,2,3]
@test Tables.getcolumn(mattbl, 1) == [1,2,3]
@test Tables.columnnames(mattbl) == [:Column1, :Column2, :Column3]
# now let&#39;s iterate our MatrixTable to get our first MatrixRow
matrow = first(mattbl)
@test eltype(mattbl) == typeof(matrow)
# now we can test our `Tables.AbstractRow` interface methods on our MatrixRow
@test matrow.Column1 == 1
@test Tables.getcolumn(matrow, :Column1) == 1
@test Tables.getcolumn(matrow, 1) == 1
@test propertynames(mattbl) == propertynames(matrow) == [:Column1, :Column2, :Column3]</code></pre><p>So, it looks like our <code>MatrixTable</code> type is looking good. It&#39;s doing everything we&#39;d expect with regards to accessing its rows or columns via the Tables.jl API methods. Testing a table source like this is fairly straightforward since we&#39;re really just testing that our interface methods are doing what we expect them to do.</p><p>Now, while we didn&#39;t go over a &quot;sink&quot; function for matrices in our walkthrough, there does indeed exist a <code>Tables.matrix</code> function that allows converting any table input source into a plain Julia <code>Matrix</code> object.</p><p>Having both Tables.jl &quot;source&quot; and &quot;sink&quot; implementations (i.e. a type that is a Tables.jl-compatible source, as well as a way to <em>consume</em> other tables), allows us to do some additional &quot;round trip&quot; testing:</p><pre><code class="language-julia hljs">rt = [(a=1, b=4.0, c=&quot;7&quot;), (a=2, b=5.0, c=&quot;8&quot;), (a=3, b=6.0, c=&quot;9&quot;)]
ct = (a=[1,2,3], b=[4.0, 5.0, 6.0])</code></pre><p>In addition to our <code>mat</code> object earlier, we can define a couple simple &quot;tables&quot;; in this case <code>rt</code> is a kind of default &quot;row table&quot; as a <code>Vector</code> of <code>NamedTuple</code>s, while <code>ct</code> is a default &quot;column table&quot; as a <code>NamedTuple</code> of <code>Vector</code>s. Notice that they contain mostly the same data as our matrix literal earlier, yet in slightly different storage formats. These default &quot;row&quot; and &quot;column&quot; tables are supported by default in Tables.jl due do their natural table representations, and hence can be excellent tools in testing table integrations.</p><pre><code class="language-julia hljs"># let&#39;s turn our row table into a plain Julia Matrix object
mat = Tables.matrix(rt)
# test that our matrix came out like we expected
@test mat[:, 1] == [1, 2, 3]
@test size(mat) == (3, 3)
@test eltype(mat) == Any
# so we successfully consumed a row-oriented table,
# now let&#39;s try with a column-oriented table
mat2 = Tables.matrix(ct)
@test eltype(mat2) == Float64
@test mat2[:, 1] == ct.a

# now let&#39;s take our matrix input, and make a column table out of it
tbl = Tables.table(mat) |&gt; columntable
@test keys(tbl) == (:Column1, :Column2, :Column3)
@test tbl.Column1 == [1, 2, 3]
# and same for a row table
tbl2 = Tables.table(mat2) |&gt; rowtable
@test length(tbl2) == 3
@test map(x-&gt;x.Column1, tbl2) == [1.0, 2.0, 3.0]</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 18 September 2022 03:36">Sunday 18 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
