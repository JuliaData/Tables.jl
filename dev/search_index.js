var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Tables.AbstractColumns","page":"API Reference","title":"Tables.AbstractColumns","text":"Tables.AbstractColumns\n\nAn interface type defined as an ordered set of columns that support retrieval of individual columns by name or index. A retrieved column must be a 1-based indexable collection with known length, i.e. an object that supports length(col) and col[i] for any i = 1:length(col). Tables.columns must return an object that satisfies the Tables.AbstractColumns interface. While Tables.AbstractColumns is an abstract type that custom \"columns\" types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects are not required to subtype, but only implement the required interface methods.\n\nInterface definition:\n\nRequired Methods Default Definition Brief Description\nTables.getcolumn(table, i::Int) getfield(table, i) Retrieve a column by index\nTables.getcolumn(table, nm::Symbol) getproperty(table, nm) Retrieve a column by name\nTables.columnnames(table) propertynames(table) Return column names for a table as a 1-based indexable collection\nOptional methods  \nTables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol) Tables.getcolumn(table, nm) Given a column eltype T, index i, and column name nm, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency.\n\nNote that subtypes of Tables.AbstractColumns must overload all required methods listed above instead of relying on these methods' default definitions.\n\nWhile types aren't required to subtype Tables.AbstractColumns, benefits of doing so include:\n\nIndexing interface defined (using getcolumn); i.e. tbl[i] will retrieve the column at index i\nProperty access interface defined (using columnnames and getcolumn); i.e. tbl.col1 will retrieve column named col1\nIteration interface defined; i.e. for col in table will iterate each column in the table\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving columns\nA default show method\n\nThis allows a custom table type to behave as close as possible to a builtin NamedTuple of vectors object.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.AbstractRow","page":"API Reference","title":"Tables.AbstractRow","text":"Tables.AbstractRow\n\nAbstract interface type representing the expected eltype of the iterator returned from Tables.rows(table). Tables.rows must return an iterator of elements that satisfy the Tables.AbstractRow interface. While Tables.AbstractRow is an abstract type that custom \"row\" types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects are not required to subtype, but only implement the required interface methods.\n\nInterface definition:\n\nRequired Methods Default Definition Brief Description\nTables.getcolumn(row, i::Int) getfield(row, i) Retrieve a column value by index\nTables.getcolumn(row, nm::Symbol) getproperty(row, nm) Retrieve a column value by name\nTables.columnnames(row) propertynames(row) Return column names for a row as a 1-based indexable collection\nOptional methods  \nTables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol) Tables.getcolumn(row, nm) Given a column element type T, index i, and column name nm, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency.\n\nNote that subtypes of Tables.AbstractRow must overload all required methods listed above instead of relying on these methods' default definitions.\n\nWhile custom row types aren't required to subtype Tables.AbstractRow, benefits of doing so include:\n\nIndexing interface defined (using getcolumn); i.e. row[i] will return the column value at index i\nProperty access interface defined (using columnnames and getcolumn); i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column value in the row\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving column values\nA default show method\n\nThis allows the custom row type to behave as close as possible to a builtin NamedTuple object.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.ByRow","page":"API Reference","title":"Tables.ByRow","text":"ByRow <: Function\n\nByRow(f) returns a function which applies function f to each element in a vector.\n\nByRow(f) can be passed two types of arguments:\n\nOne or more 1-based AbstractVectors of equal length: In this case the returned value is a vector resulting from applying f to elements of passed vectors element-wise. Function f is called exactly once for each element of passed vectors (as opposed to map which assumes for some types of source vectors (e.g. SparseVector) that the wrapped function is pure, and may call the function f only once for multiple equal values.\nA Tables.ColumnTable holding 1-based columns of equal length: In this case the function f is passed a NamedTuple created for each row of passed table.\n\nThe return value of ByRow(f) is always a vector.\n\nByRow expects that at least one argument is passed to it and in the case of Tables.ColumnTable passed that the table has at least one column. In some contexts of operations on tables (for example DataFrame) the user might want to pass no arguments (or an empty Tables.ColumnTable) to ByRow. This case must be separately handled by the code implementing the logic of processing the ByRow operation on this specific parent table (the reason is that passing such arguments to ByRow does not allow it to determine the number of rows of the source table).\n\nExamples\n\njulia> Tables.ByRow(x -> x^2)(1:3)\n3-element Vector{Int64}:\n 1\n 4\n 9\n\njulia> Tables.ByRow((x, y) -> x*y)(1:3, 2:4)\n3-element Vector{Int64}:\n  2\n  6\n 12\n\njulia> Tables.ByRow(x -> x.a)((a=1:2, b=3:4))\n2-element Vector{Int64}:\n 1\n 2\n\n julia> Tables.ByRow(x -> (a=x.a*2, b=sin(x.b), c=x.c))((a=[1, 2, 3],\n                                                         b=[1.2, 3.4, 5.6],\n                                                         c=[\"a\", \"b\", \"c\"]))\n3-element Vector{NamedTuple{(:a, :b, :c), Tuple{Int64, Float64, String}}}:\n (a = 2, b = 0.9320390859672263, c = \"a\")\n (a = 4, b = -0.2555411020268312, c = \"b\")\n (a = 6, b = -0.6312666378723216, c = \"c\")\n\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.Columns","page":"API Reference","title":"Tables.Columns","text":"Tables.Columns(tbl)\n\nConvenience type that calls Tables.columns on an input tbl and wraps the resulting AbstractColumns interface object in a dedicated struct to provide useful default behaviors (allows any AbstractColumns to be used like a NamedTuple of Vectors):\n\nIndexing interface defined; i.e. row[i] will return the column at index i, row[nm] will return column for column name nm\nProperty access interface defined; i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column in the row\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving columns\n\nNote that Tables.Columns calls Tables.columns internally on the provided table argument. Tables.Columns can be used for dispatch if needed.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.CopiedColumns","page":"API Reference","title":"Tables.CopiedColumns","text":"Tables.CopiedColumns\n\nFor some sinks, there's a concern about whether they can safely \"own\" columns from the input. If mutation will be allowed, to be safe, they should always copy input columns, to avoid unintended mutation to the original source. When we've called buildcolumns, however, Tables.jl essentially built/owns the columns, and it's happy to pass ownership to the sink. Thus, any built columns will be wrapped in a CopiedColumns struct to signal to the sink that essentially \"a copy has already been made\" and they're safe to assume ownership.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.LazyTable","page":"API Reference","title":"Tables.LazyTable","text":"Tables.LazyTable(f, arg)\n\nA \"table\" type that delays materialization until Tables.columns or Tables.rows is called. This allows, for example, sending a LazyTable to a remote process or thread which can then call Tables.columns or Tables.rows to \"materialize\" the table. Is used by default in Tables.partitioner(f, itr) where a materializer function f is passed to each element of an iterable itr, allowing distributed/concurrent patterns like:\n\nfor tbl in Tables.partitions(Tables.partitioner(CSV.File, list_of_csv_files))\n    Threads.@spawn begin\n        cols = Tables.columns(tbl)\n        # do stuff with cols\n    end\nend\n\nIn this example, CSV.File will be called like CSV.File(x) for each element of the list_of_csv_files iterable, but not until Tables.columns(tbl) is called, which in this case happens in a thread-spawned task, allowing files to be parsed and processed in parallel.\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.Row","page":"API Reference","title":"Tables.Row","text":"Tables.Row(row)\n\nConvenience type to wrap any AbstractRow interface object in a dedicated struct to provide useful default behaviors (allows any AbstractRow to be used like a NamedTuple):\n\nIndexing interface defined; i.e. row[i] will return the column value at index i, row[nm] will return column value for column name nm\nProperty access interface defined; i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column value in the row\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving column values\n\n\n\n\n\n","category":"type"},{"location":"api/#Tables.Schema","page":"API Reference","title":"Tables.Schema","text":"Tables.Schema(names, types)\n\nCreate a Tables.Schema object that holds the column names and types for an AbstractRow iterator returned from Tables.rows or an AbstractColumns object returned from Tables.columns. Tables.Schema is dual-purposed: provide an easy interface for users to query these properties, as well as provide a convenient \"structural\" type for code generation.\n\nTo get a table's schema, one can call Tables.schema on the result of Tables.rows or Tables.columns, but also note that a table may return nothing, indicating that its column names and/or column element types are unknown (usually not inferable). This is similar to the Base.EltypeUnknown() trait for iterators when Base.IteratorEltype is called. Users should account for the Tables.schema(tbl) => nothing case by using the properties of the results of Tables.rows(x) and Tables.columns(x) directly.\n\nTo access the names, one can simply call sch.names to return a collection of Symbols (Tuple or Vector). To access column element types, one can similarly call sch.types, which will return a collection of types (like (Int64, Float64, String)).\n\nThe actual type definition is\n\nstruct Schema{names, types}\n    storednames::Union{Nothing, Vector{Symbol}}\n    storedtypes::Union{Nothing, Vector{Type}}\nend\n\nWhere names is a tuple of Symbols or nothing, and types is a tuple type of types (like Tuple{Int64, Float64, String}) or nothing. Encoding the names & types as type parameters allows convenient use of the type in generated functions and other optimization use-cases, but users should note that when names and/or types are the nothing value, the names and/or types are stored in the storednames and storedtypes fields. This is to account for extremely wide tables with columns in the 10s of thousands where encoding the names/types as type parameters becomes prohibitive to the compiler. So while optimizations can be written on the typed names/types type parameters, users should also consider handling the extremely wide tables by specializing on Tables.Schema{nothing, nothing}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api/#Tables.allocatecolumn-Tuple{Any, Any}","page":"API Reference","title":"Tables.allocatecolumn","text":"Tables.allocatecolumn(::Type{T}, len) => returns a column type (usually `AbstractVector`) with size to hold `len` elements\n\nCustom column types can override with an appropriate \"scalar\" element type that should dispatch to their column allocator. Alternatively, and more generally, custom scalars can overload DataAPI.defaultarray to signal the default array type. In this case the signaled array type must support a constructor accepting undef for initialization.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.columnaccess","page":"API Reference","title":"Tables.columnaccess","text":"Tables.columnaccess(x) => Bool\n\nCheck whether an object has specifically defined that it implements the Tables.columns function that does not copy table data.  That is to say, Tables.columns(x) must be done with O(1) time and space complexity when Tables.columnaccess(x) == true.  Note that Tables.columns has generic fallbacks allowing it to produces AbstractColumns objects, even if the input doesn't define columnaccess.  However, this generic fallback may copy the data from input table x.  Also note that just because an object defines columnaccess doesn't mean a user should call Tables.columns on it; Tables.rows will also work, providing a valid AbstractRow iterator. Hence, users should call Tables.rows or Tables.columns depending on what is most natural for them to consume instead of worrying about what and how the input is oriented.\n\nIt is recommended that for users implementing MyType, they define only columnaccess(::Type{MyType}). columnaccess(::MyType) will then automatically delegate to this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.columnindex-Tuple{Any, Symbol}","page":"API Reference","title":"Tables.columnindex","text":"Tables.columnindex(table, name::Symbol)\n\nReturn the column index (1-based) of a column by name in a table with a known schema; returns 0 if name doesn't exist in table\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.columnindex-Tuple{Tuple{Vararg{Symbol}}, Symbol}","page":"API Reference","title":"Tables.columnindex","text":"given names and a Symbol name, compute the index (1-based) of the name in names\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.columnnames","page":"API Reference","title":"Tables.columnnames","text":"Tables.columnnames(::Union{AbstractColumns, AbstractRow}) => Indexable collection\n\nRetrieves the list of column names as a 1-based indexable collection (like a Tuple or Vector) for a AbstractColumns or AbstractRow interface object. The default definition calls propertynames(x). The returned column names must be unique.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.columns","page":"API Reference","title":"Tables.columns","text":"Tables.columns(x) => AbstractColumns-compatible object\n\nAccesses data of input table source x by returning an AbstractColumns-compatible object, which allows retrieving entire columns by name or index. A retrieved column is a 1-based indexable object that has a known length, i.e. supports length(col) and col[i] for any i = 1:length(col). Note that even if the input table source is row-oriented by nature, an efficient generic definition of Tables.columns is defined in Tables.jl to build a AbstractColumns- compatible object object from the input rows.\n\nThe Tables.Schema of a AbstractColumns object can be queried via Tables.schema(columns), which may return nothing if the schema is unknown. Column names can always be queried by calling Tables.columnnames(columns), and individual columns can be accessed by calling Tables.getcolumn(columns, i::Int ) or Tables.getcolumn(columns, nm::Symbol) with a column index or name, respectively.\n\nNote that if x is an object in which columns are stored as vectors, the check that these vectors use 1-based indexing is not performed (it should be ensured when x is constructed).\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.columntable","page":"API Reference","title":"Tables.columntable","text":"Tables.columntable(x) => NamedTuple of AbstractVectors\n\nTakes any input table source x and returns a NamedTuple of AbstractVectors, also known as a \"column table\". A \"column table\" is a kind of default table type of sorts, since it satisfies the Tables.jl column interface naturally.\n\nNote that if x is an object in which columns are stored as vectors, the check that these vectors use 1-based indexing is not performed (it should be ensured when x is constructed).\n\nNot for use with extremely wide tables with # of columns > 67K; current fundamental compiler limits prevent constructing NamedTuples that large.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.columntype-Tuple{Any, Symbol}","page":"API Reference","title":"Tables.columntype","text":"Tables.columntype(table, name::Symbol)\n\nReturn the column element type of a column by name in a table with a known schema; returns Union{} if name doesn't exist in table\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.columntype-Union{Tuple{types}, Tuple{Tuple{Vararg{Symbol}}, Type{types}, Symbol}} where types<:Tuple","page":"API Reference","title":"Tables.columntype","text":"given tuple type and a Symbol name, compute the type of the name in the tuples types\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.datavaluerows-Tuple{Any}","page":"API Reference","title":"Tables.datavaluerows","text":"Tables.datavaluerows(x) => NamedTuple iterator\n\nTakes any table input x and returns a NamedTuple iterator that will replace missing values with DataValue-wrapped values; this allows any table type to satisfy the TableTraits.jl  Queryverse integration interface by defining: \n\nIteratorInterfaceExtensions.getiterator(x::MyTable) = Tables.datavaluerows(x)\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.dictcolumntable-Tuple{Any}","page":"API Reference","title":"Tables.dictcolumntable","text":"Tables.dictcolumntable(x) => Tables.DictColumnTable\n\nTake any Tables.jl-compatible source x and return a DictColumnTable, which can be thought of as a OrderedDict mapping column names as Symbols to AbstractVectors. The order of the input table columns is preserved via the Tables.schema(::DictColumnTable).\n\nFor \"schema-less\" input tables, dictcolumntable employs a \"column unioning\" behavior, as opposed to inferring the schema from the first row like Tables.columns. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value missing, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it's recommended to use only when needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.dictrowtable-Tuple{Any}","page":"API Reference","title":"Tables.dictrowtable","text":"Tables.dictrowtable(x) => Tables.DictRowTable\n\nTake any Tables.jl-compatible source x and return a DictRowTable, which can be thought of as a Vector of OrderedDict rows mapping column names as Symbols to values. The order of the input table columns is preserved via the Tables.schema(::DictRowTable).\n\nFor \"schema-less\" input tables, dictrowtable employs a \"column unioning\" behavior, as opposed to inferring the schema from the first row like Tables.columns. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value missing, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it's recommended to use only when the union behavior is needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.eachcolumn","page":"API Reference","title":"Tables.eachcolumn","text":"Tables.eachcolumn(f, sch::Tables.Schema{names, types}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})\nTables.eachcolumn(f, sch::Tables.Schema{names, nothing}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})\n\nTakes a function f, table schema sch, x, which is an object that satisfies the AbstractRow or AbstractColumns interfaces; it generates calls to get the value for each column (Tables.getcolumn(x, nm)) and then calls f(val, index, name), where f is the user-provided function, val is the column value (AbstractRow) or entire column (AbstractColumns), index is the column index as an Int, and name is the column name as a Symbol.\n\nAn example using Tables.eachcolumn is:\n\nrows = Tables.rows(tbl)\nsch = Tables.schema(rows)\nif sch === nothing\n    state = iterate(rows)\n    state === nothing && return\n    row, st = state\n    sch = Tables.schema(Tables.columnnames(row), nothing)\n    while state !== nothing\n        Tables.eachcolumn(sch, row) do val, i, nm\n            bind!(stmt, i, val)\n        end\n        state = iterate(rows, st)\n        state === nothing && return\n        row, st = state\n    end\nelse\n    for row in rows\n        Tables.eachcolumn(sch, row) do val, i, nm\n            bind!(stmt, i, val)\n        end\n    end\nend\n\nNote in this example we account for the input table potentially returning nothing from Tables.schema(rows); in that case, we start iterating the rows, and build a partial schema using the column names from the first row sch = Tables.schema(Tables.columnnames(row), nothing), which is valid to pass to Tables.eachcolumn.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.getcolumn","page":"API Reference","title":"Tables.getcolumn","text":"Tables.getcolumn(::AbstractColumns, nm::Symbol) => Indexable collection with known length\nTables.getcolumn(::AbstractColumns, i::Int) => Indexable collection with known length\nTables.getcolumn(::AbstractColumns, T, i::Int, nm::Symbol) => Indexable collection with known length\n\nTables.getcolumn(::AbstractRow, nm::Symbol) => Column value\nTables.getcolumn(::AbstractRow, i::Int) => Column value\nTables.getcolumn(::AbstractRow, T, i::Int, nm::Symbol) => Column value\n\nRetrieve an entire column (from AbstractColumns) or single row column value (from an AbstractRow) by column name (nm), index (i), or if desired, by column element type (T), index (i), and name (nm). When called on a AbstractColumns interface object, the returned object should be a 1-based indexable collection with known length. When called on a AbstractRow interface object, it returns the single column value. The methods taking a single Symbol or Int are both required for the AbstractColumns and AbstractRow interfaces; the third method is optional if type stability is possible. The default definition of Tables.getcolumn(x, i::Int) is getfield(x, i). The default definition of Tables.getcolumn(x, nm::Symbol) is getproperty(x, nm).\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.isrowtable","page":"API Reference","title":"Tables.isrowtable","text":"Tables.isrowtable(x) => Bool\n\nFor convenience, some table objects that are naturally \"row oriented\" can define Tables.isrowtable(::Type{TableType}) = true to simplify satisfying the Tables.jl interface. Requirements for defining isrowtable include:\n\nTables.rows(x) === x, i.e. the table object itself is a Row iterator\nIf the table object is mutable, it should support:\npush!(x, row): allow pushing a single row onto table\nappend!(x, rows): allow appending set of rows onto table\nIf table object is mutable and indexable, it should support:\nx[i] = row: allow replacing of a row with another row by index\n\nA table object that defines Tables.isrowtable will have definitions for Tables.istable, Tables.rowaccess, and Tables.rows automatically defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.istable","page":"API Reference","title":"Tables.istable","text":"Tables.istable(x) => Bool\n\nCheck if an object has specifically defined that it is a table. Note that not all valid tables will return true, since it's possible to satisfy the Tables.jl interface at \"run-time\", e.g. a Generator of NamedTuples iterates NamedTuples, which satisfies the AbstractRow interface, but there's no static way of knowing that the generator is a table.\n\nIt is recommended that for users implementing MyType, they define only istable(::Type{MyType}). istable(::MyType) will then automatically delegate to this method.\n\nistable calls TableTraits.isiterabletable as a fallback. This can have a considerable runtime overhead in some contexts. To avoid these and use istable as a compile-time trait, it can be called on a type as istable(typeof(obj)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.materializer","page":"API Reference","title":"Tables.materializer","text":"Tables.materializer(x) => Callable\n\nFor a table input, return the \"sink\" function or \"materializing\" function that can take a Tables.jl-compatible table input and make an instance of the table type. This enables \"transform\" workflows that take table inputs, apply transformations, potentially converting the table to a different form, and end with producing a table of the same type as the original input. The default materializer is Tables.columntable, which converts any table input into a NamedTuple of Vectors.\n\nIt is recommended that for users implementing MyType, they define only materializer(::Type{<:MyType}). materializer(::MyType) will then automatically delegate to this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.matrix-Tuple{Any}","page":"API Reference","title":"Tables.matrix","text":"Tables.matrix(table; transpose::Bool=false)\n\nMaterialize any table source input as a new Matrix or in the case of a MatrixTable return the originally wrapped matrix. If the table column element types are not homogeneous, they will be promoted to a common type in the materialized Matrix. Note that column names are ignored in the conversion. By default, input table columns will be materialized as corresponding matrix columns; passing transpose=true will transpose the input with input columns as matrix rows or in the case of a MatrixTable apply permutedims to the originally wrapped matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.namedtupleiterator-Tuple{Any}","page":"API Reference","title":"Tables.namedtupleiterator","text":"Tables.namedtupleiterator(x)\n\nPass any table input source and return a NamedTuple iterator\n\nSee also rows and rowtable.\n\nNot for use with extremely wide tables with # of columns > 67K; current fundamental compiler limits prevent constructing NamedTuples that large.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.nondatavaluerows-Tuple{Any}","page":"API Reference","title":"Tables.nondatavaluerows","text":"Tables.nondatavaluerows(x)\n\nTakes any Queryverse-compatible NamedTuple iterator source and  converts to a Tables.jl-compatible AbstractRow iterator. Will automatically unwrap any DataValues, replacing NA with missing. Useful for translating Query.jl results back to non-DataValue-based tables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.partitioner-Tuple{Any}","page":"API Reference","title":"Tables.partitioner","text":"Tables.partitioner(f, itr)\nTables.partitioner(x)\n\nConvenience methods to generate table iterators. The first method takes a \"materializer\" function f and an iterator itr, and will call Tables.LazyTable(f, x) for x in itr for each iteration. This allows delaying table materialization until Tables.columns or Tables.rows are called on the LazyTable object (which will call f(x)). This allows a common desired pattern of materializing and processing a table on a remote process or thread, like:\n\nfor tbl in Tables.partitions(Tables.partitioner(CSV.File, list_of_csv_files))\n    Threads.@spawn begin\n        cols = Tables.columns(tbl)\n        # do stuff with cols\n    end\nend\n\nThe second method is provided because the default behavior of Tables.partition(x) is to treat x as a single, non-partitioned table. This method allows users to easily wrap a Vector or generator of tables as table partitions to pass to sink functions able to utilize Tables.partitions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.partitions-Tuple{Any}","page":"API Reference","title":"Tables.partitions","text":"Tables.partitions(x)\n\nRequest a \"table\" iterator from x. Each iterated element must be a \"table\" in the sense that one may call Tables.rows or Tables.columns to get a row-iterator or collection of columns. All iterated elements must have identical schema, so that users may call Tables.schema(first_element) on the first iterated element and know that each subsequent iteration will match the same schema. The default definition is:\n\nTables.partitions(x) = (x,)\n\nSo that any input is assumed to be a single \"table\". This means users should feel free to call Tables.partitions anywhere they're currently calling Tables.columns or Tables.rows, and get back an iterator of those instead. In other words, \"sink\" functions can use Tables.partitions whether or not the user passes a partionable table, since the default is to treat a single input as a single, non-partitioned table.\n\nTables.partitioner(itr) is a convenience wrapper to provide table partitions from any table iterator; this allows for easy wrapping of a Vector or iterator of tables as valid partitions, since by default, they'd be treated as a single table.\n\nA 2nd convenience method is provided with the definition:\n\nTables.partitions(x...) = x\n\nThat allows passing vararg tables and they'll be treated as separate partitions. Sink functions may allow vararg table inputs and can \"splat them through\" to partitions.\n\nFor convenience, Tables.partitions(x::Iterators.PartitionIterator) = x and Tables.partitions(x::Tables.Partitioner) = x are defined to handle cases where user created partitioning with the Iterators.partition or Tables.partitioner functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.rowaccess","page":"API Reference","title":"Tables.rowaccess","text":"Tables.rowaccess(x) => Bool\n\nCheck whether an object has specifically defined that it implements the Tables.rows function that does not copy table data.  That is to say, Tables.rows(x) must be done with O(1) time and space complexity when Tables.rowaccess(x) == true.  Note that Tables.rows will work on any object that iterates AbstractRow-compatible objects, even if they don't define rowaccess, e.g. a Generator of NamedTuples.  However, this generic fallback may copy the data from input table x.  Also note that just because an object defines rowaccess doesn't mean a user should call Tables.rows on it; Tables.columns will also work, providing a valid AbstractColumns object from the rows. Hence, users should call Tables.rows or Tables.columns depending on what is most natural for them to consume instead of worrying about what and how the input is oriented.\n\nIt is recommended that for users implementing MyType, they define only rowaccess(::Type{MyType}). rowaccess(::MyType) will then automatically delegate to this method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.rowmerge-Tuple{Any, Any}","page":"API Reference","title":"Tables.rowmerge","text":"rowmerge(row, other_rows...)\nrowmerge(row; fields_to_merge...)\n\nReturn a NamedTuple by merging row (an AbstractRow-compliant value) with other_rows (one or more AbstractRow-compliant values) via Base.merge. This function is similar to Base.merge(::NamedTuple, ::NamedTuple...), but accepts AbstractRow-compliant values instead of NamedTuples.\n\nA convenience method rowmerge(row; fields_to_merge...) = rowmerge(row, fields_to_merge) is defined that enables the fields_to_merge to be specified as keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.rows","page":"API Reference","title":"Tables.rows","text":"Tables.rows(x) => Row iterator\n\nAccesses data of input table source x row-by-row by returning an AbstractRow-compatible iterator. Note that even if the input table source is column-oriented by nature, an efficient generic definition of Tables.rows is defined in Tables.jl to return an iterator of row views into the columns of the input.\n\nThe Tables.Schema of an AbstractRow iterator can be queried via Tables.schema(rows), which may return nothing if the schema is unknown. Column names can always be queried by calling Tables.columnnames(row) on an individual row, and row values can be accessed by calling Tables.getcolumn(row, i::Int ) or Tables.getcolumn(row, nm::Symbol) with a column index or name, respectively.\n\nSee also rowtable and namedtupleiterator.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.rowtable","page":"API Reference","title":"Tables.rowtable","text":"Tables.rowtable(x) => Vector{NamedTuple}\n\nTake any input table source, and produce a Vector of NamedTuples, also known as a \"row table\". A \"row table\" is a kind of default table type of sorts, since it satisfies the Tables.jl row interface naturally, i.e. a Vector naturally iterates its elements, and NamedTuple satisfies the AbstractRow interface by default (allows indexing value by index, name, and getting all names).\n\nFor a lazy iterator over rows see rows and namedtupleiterator.\n\nNot for use with extremely wide tables with # of columns > 67K; current fundamental compiler limits prevent constructing NamedTuples that large.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.runlength-Union{Tuple{Type{T}}, Tuple{T}} where T<:Tuple","page":"API Reference","title":"Tables.runlength","text":"helper function to calculate a run-length encoding of a tuple type\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.schema","page":"API Reference","title":"Tables.schema","text":"Tables.schema(x) => Union{Nothing, Tables.Schema}\n\nAttempt to retrieve the schema of the object returned by Tables.rows or Tables.columns. If the AbstractRow iterator or AbstractColumns object can't determine its schema, nothing will be returned. Otherwise, a Tables.Schema object is returned, with the column names and types available for use.\n\n\n\n\n\n","category":"function"},{"location":"api/#Tables.subset-Union{Tuple{T}, Tuple{T, Any}} where T","page":"API Reference","title":"Tables.subset","text":"Tables.subset(x, inds; viewhint=nothing)\n\nReturn one or more rows from table x according to the position(s) specified by inds:\n\nIf inds is a single non-boolean integer return a row object.\nIf inds is a vector of non-boolean integers, a vector of booleans, or a :, return a subset of the original table according to the indices. In this case, the returned type is not necessarily the same as the original table type.\n\nIf other types of inds are passed than specified above the behavior is undefined.\n\nThe viewhint argument tries to influence whether the returned object is a view of the original table or an independent copy:\n\nIf viewhint=nothing (the default) then the implementation for a specific table type is free to decide  whether to return a copy or a view.\nIf viewhint=true then a view is returned and if viewhint=false a copy is returned. This applies both to returning a row or a table.\n\nAny specialized implementation of subset must support the viewhint=nothing argument. Support for viewhint=true or viewhint=false is optional (i.e. implementations may ignore the keyword argument and return a view or a copy regardless of viewhint value).\n\n\n\n\n\n","category":"method"},{"location":"api/#Tables.table-Tuple{AbstractVecOrMat}","page":"API Reference","title":"Tables.table","text":"Tables.table(m::AbstractVecOrMat; [header])\n\nWrap an AbstractVecOrMat (Matrix, Vector, Adjoint, etc.) in a MatrixTable, which satisfies the Tables.jl interface.  (An AbstractVector is treated as a 1-column matrix.) This allows accessing the matrix via Tables.rows and Tables.columns. An optional keyword argument iterator header can be passed which will be converted to a Vector{Symbol} to be used as the column names. Note that no copy of the AbstractVecOrMat is made.\n\n\n\n\n\n","category":"method"},{"location":"using-the-interface/#Using-the-Interface-(i.e.-consuming-Tables.jl-compatible-sources)","page":"Using the Interface","title":"Using the Interface (i.e. consuming Tables.jl-compatible sources)","text":"","category":"section"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"We start by discussing usage of the Tables.jl interface functions, since that can help contextualize implementing them for custom table types.","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"At a high level, Tables.jl provides two powerful APIs for predictably accessing data from any table-like source:","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"# access data of input table `x` row-by-row\n# Tables.rows must return a row iterator\nrows = Tables.rows(x)\n\n# we can iterate through each row\nfor row in rows\n    # example of getting all values in the row\n    # don't worry, there are other ways to more efficiently process rows\n    rowvalues = [Tables.getcolumn(row, col) for col in Tables.columnnames(row)]\nend\n\n# access data of input table `x` column-by-column\n# Tables.columns returns an object where individual, entire columns can be accessed\ncolumns = Tables.columns(x)\n\n# iterate through each column name in table\nfor col in Tables.columnnames(columns)\n    # retrieve entire column by column name\n    # a column is an indexable collection\n    # with known length (i.e. supports\n    # `length(column)` and `column[i]`)\n    column = Tables.getcolumn(columns, col)\nend","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"So we see two high-level functions here, Tables.rows, and Tables.columns.","category":"page"},{"location":"using-the-interface/#Tables.rows-using-the-interface","page":"Using the Interface","title":"Tables.rows","text":"Tables.rows(x) => Row iterator\n\nAccesses data of input table source x row-by-row by returning an AbstractRow-compatible iterator. Note that even if the input table source is column-oriented by nature, an efficient generic definition of Tables.rows is defined in Tables.jl to return an iterator of row views into the columns of the input.\n\nThe Tables.Schema of an AbstractRow iterator can be queried via Tables.schema(rows), which may return nothing if the schema is unknown. Column names can always be queried by calling Tables.columnnames(row) on an individual row, and row values can be accessed by calling Tables.getcolumn(row, i::Int ) or Tables.getcolumn(row, nm::Symbol) with a column index or name, respectively.\n\nSee also rowtable and namedtupleiterator.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.columns-using-the-interface","page":"Using the Interface","title":"Tables.columns","text":"Tables.columns(x) => AbstractColumns-compatible object\n\nAccesses data of input table source x by returning an AbstractColumns-compatible object, which allows retrieving entire columns by name or index. A retrieved column is a 1-based indexable object that has a known length, i.e. supports length(col) and col[i] for any i = 1:length(col). Note that even if the input table source is row-oriented by nature, an efficient generic definition of Tables.columns is defined in Tables.jl to build a AbstractColumns- compatible object object from the input rows.\n\nThe Tables.Schema of a AbstractColumns object can be queried via Tables.schema(columns), which may return nothing if the schema is unknown. Column names can always be queried by calling Tables.columnnames(columns), and individual columns can be accessed by calling Tables.getcolumn(columns, i::Int ) or Tables.getcolumn(columns, nm::Symbol) with a column index or name, respectively.\n\nNote that if x is an object in which columns are stored as vectors, the check that these vectors use 1-based indexing is not performed (it should be ensured when x is constructed).\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"Given these two powerful data access methods, let's walk through real, albeit somewhat simplified versions of how packages actually use these methods.","category":"page"},{"location":"using-the-interface/#Tables.rows-usage","page":"Using the Interface","title":"Tables.rows usage","text":"","category":"section"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"First up, let's take a look at the SQLite.jl package and how it uses the Tables.jl interface to allow loading of generic table-like data into a sqlite relational table. Here's the code:","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"function load!(table, db::SQLite.DB, tablename)\n    # get input table rows\n    rows = Tables.rows(table)\n    # query for schema of data\n    sch = Tables.schema(rows)\n    # create table using tablename and schema from input table\n    createtable!(db, tablename, sch)\n    # build insert statement\n    params = chop(repeat(\"?,\", length(sch.names)))\n    stmt = Stmt(db, \"INSERT INTO $tablename VALUES ($params)\")\n    # start a transaction for inserting rows\n    transaction(db) do\n        # iterate over rows in the input table\n        for row in rows\n            # Tables.jl provides a utility function\n            # Tables.eachcolumn, which allows efficiently\n            # applying a function to each column value in a row\n            # it's called with a schema and row, and applies\n            # a user-provided function to the column value `val`, index `i`\n            # and column name `nm`. Here, we bind the row values\n            # to our parameterized SQL INSERT statement and then\n            # call `sqlite3_step` to execute the INSERT statement.\n            Tables.eachcolumn(sch, row) do val, i, nm\n                bind!(stmt, i, val)\n            end\n            sqlite3_step(stmt.handle)\n            sqlite3_reset(stmt.handle)\n        end\n    end\n    return\nend","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"This is pretty straightforward usage: it calls Tables.rows on the input table source, and since we need the schema to setup the database table, we query it via Tables.schema. We then iterate the rows in our table via for row in rows, and use the convenient Tables.eachcolumn to efficiently apply a function to each value in the row. Note that we didn't call Tables.columnnames or Tables.getcolumn at all, since they're utilized by Tables.eachcolumn itself. Tables.eachcolumn is optimized to provide type-stable, and even constant-propagation of column index, name, and type in some cases to allow for efficient consumption of row values.","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"One wrinkle to consider is the \"unknown schema\" case; i.e. what if our Tables.schema call had returned nothing (this can be the case for exotic table sources like lazily mapped transformations over rows in a table):","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"function load!(sch::Nothing, rows, db::SQLite.DB, tablename)\n    # sch is nothing === unknown schema\n    # start iteration on input table rows\n    state = iterate(rows)\n    state === nothing && return\n    row, st = state\n    # query column names of first row\n    names = Tables.columnnames(row)\n    # partially construct Tables.Schema by at least passing\n    # the column names to it\n    sch = Tables.Schema(names, nothing)\n    # create table if needed\n    createtable!(db, tablename, sch)\n    # build insert statement\n    params = chop(repeat(\"?,\", length(names)))\n    stmt = Stmt(db, \"INSERT INTO $nm VALUES ($params)\")\n    # start a transaction for inserting rows\n    transaction(db) do\n        while true\n            # just like before, we can still use `Tables.eachcolumn`\n            # even with our partially constructed Tables.Schema\n            # to apply a function to each value in the row\n            Tables.eachcolumn(sch, row) do val, i, nm\n                bind!(stmt, i, val)\n            end\n            sqlite3_step(stmt.handle)\n            sqlite3_reset(stmt.handle)\n            # keep iterating rows until we finish\n            state = iterate(rows, st)\n            state === nothing && break\n            row, st = state\n        end\n    end\n    return name\nend","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"The strategy taken here is to start iterating the input source, and using the first row as a guide, we make a Tables.Schema object with just the column names, which we can then still pass to Tables.eachcolumn to apply our bind! function to each row value.","category":"page"},{"location":"using-the-interface/#Tables.columns-usage","page":"Using the Interface","title":"Tables.columns usage","text":"","category":"section"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"Ok, now let's take a look at a case utilizing Tables.columns. The following code is taken from the DataFrames.jl Tables.jl implementation:","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"getvector(x::AbstractVector) = x\ngetvector(x) = collect(x)\n\n# note that copycols is ignored in this definition (Tables.CopiedColumns implies copies have already been made)\nfromcolumns(x::Tables.CopiedColumns, names; copycols::Bool=true) =\n    DataFrame(AbstractVector[getvector(Tables.getcolumn(x, nm) for nm in names],\n              Index(names),\n              copycols=false)\nfromcolumns(x, names; copycols::Bool=true) =\n    DataFrame(AbstractVector[getvector(Tables.getcolumn(x, nm) for nm in names],\n              Index(names),\n              copycols=copycols)\n\nfunction DataFrame(x; copycols::Bool=true)\n    # get columns from input table source\n    cols = Tables.columns(x)\n    # get column names as Vector{Symbol}, which is required\n    # by core DataFrame constructor\n    names = collect(Symbol, Tables.columnnames(cols))\n    return fromcolumns(cols, names; copycols=copycols)\nend","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"So here we have a generic DataFrame constructor that takes a single, untyped argument, calls Tables.columns on it, then Tables.columnnames to get the column names. It then passes the Tables.AbstractColumns-compatible object to an internal function fromcolumns, which dispatches on a special kind of Tables.AbstractColumns object called a Tables.CopiedColumns, which wraps any Tables.AbstractColumns-compatible object that has already had copies of its columns made, and are thus safe for the columns-consumer to assume ownership of (this is because DataFrames.jl, by default makes copies of all columns upon construction). In both cases, individual columns are collected in Vector{AbstractVector}s by calling Tables.getcolumn(x, nm) for each column name. A final note is the call to getvector on each column, which ensures each column is materialized as an AbstractVector, as is required by the DataFrame constructor.","category":"page"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"Note in both the rows and columns usages, we didn't need to worry about the natural orientation of the input data; we just called Tables.rows or Tables.columns as was most natural for the table-specific use-case, knowing that it will Just Work™️.","category":"page"},{"location":"using-the-interface/#Tables.jl-Utilities","page":"Using the Interface","title":"Tables.jl Utilities","text":"","category":"section"},{"location":"using-the-interface/","page":"Using the Interface","title":"Using the Interface","text":"Before moving on to implementing the Tables.jl interfaces, we take a quick break to highlight some useful utility functions provided by Tables.jl:","category":"page"},{"location":"using-the-interface/#Tables.Schema-using-the-interface","page":"Using the Interface","title":"Tables.Schema","text":"Tables.Schema(names, types)\n\nCreate a Tables.Schema object that holds the column names and types for an AbstractRow iterator returned from Tables.rows or an AbstractColumns object returned from Tables.columns. Tables.Schema is dual-purposed: provide an easy interface for users to query these properties, as well as provide a convenient \"structural\" type for code generation.\n\nTo get a table's schema, one can call Tables.schema on the result of Tables.rows or Tables.columns, but also note that a table may return nothing, indicating that its column names and/or column element types are unknown (usually not inferable). This is similar to the Base.EltypeUnknown() trait for iterators when Base.IteratorEltype is called. Users should account for the Tables.schema(tbl) => nothing case by using the properties of the results of Tables.rows(x) and Tables.columns(x) directly.\n\nTo access the names, one can simply call sch.names to return a collection of Symbols (Tuple or Vector). To access column element types, one can similarly call sch.types, which will return a collection of types (like (Int64, Float64, String)).\n\nThe actual type definition is\n\nstruct Schema{names, types}\n    storednames::Union{Nothing, Vector{Symbol}}\n    storedtypes::Union{Nothing, Vector{Type}}\nend\n\nWhere names is a tuple of Symbols or nothing, and types is a tuple type of types (like Tuple{Int64, Float64, String}) or nothing. Encoding the names & types as type parameters allows convenient use of the type in generated functions and other optimization use-cases, but users should note that when names and/or types are the nothing value, the names and/or types are stored in the storednames and storedtypes fields. This is to account for extremely wide tables with columns in the 10s of thousands where encoding the names/types as type parameters becomes prohibitive to the compiler. So while optimizations can be written on the typed names/types type parameters, users should also consider handling the extremely wide tables by specializing on Tables.Schema{nothing, nothing}.\n\n\n\n\n\n","category":"type"},{"location":"using-the-interface/#Tables.schema-using-the-interface","page":"Using the Interface","title":"Tables.schema","text":"Tables.schema(x) => Union{Nothing, Tables.Schema}\n\nAttempt to retrieve the schema of the object returned by Tables.rows or Tables.columns. If the AbstractRow iterator or AbstractColumns object can't determine its schema, nothing will be returned. Otherwise, a Tables.Schema object is returned, with the column names and types available for use.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.subset-using-the-interface","page":"Using the Interface","title":"Tables.subset","text":"Tables.subset(x, inds; viewhint=nothing)\n\nReturn one or more rows from table x according to the position(s) specified by inds:\n\nIf inds is a single non-boolean integer return a row object.\nIf inds is a vector of non-boolean integers, a vector of booleans, or a :, return a subset of the original table according to the indices. In this case, the returned type is not necessarily the same as the original table type.\n\nIf other types of inds are passed than specified above the behavior is undefined.\n\nThe viewhint argument tries to influence whether the returned object is a view of the original table or an independent copy:\n\nIf viewhint=nothing (the default) then the implementation for a specific table type is free to decide  whether to return a copy or a view.\nIf viewhint=true then a view is returned and if viewhint=false a copy is returned. This applies both to returning a row or a table.\n\nAny specialized implementation of subset must support the viewhint=nothing argument. Support for viewhint=true or viewhint=false is optional (i.e. implementations may ignore the keyword argument and return a view or a copy regardless of viewhint value).\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.partitions-using-the-interface","page":"Using the Interface","title":"Tables.partitions","text":"Tables.partitions(x)\n\nRequest a \"table\" iterator from x. Each iterated element must be a \"table\" in the sense that one may call Tables.rows or Tables.columns to get a row-iterator or collection of columns. All iterated elements must have identical schema, so that users may call Tables.schema(first_element) on the first iterated element and know that each subsequent iteration will match the same schema. The default definition is:\n\nTables.partitions(x) = (x,)\n\nSo that any input is assumed to be a single \"table\". This means users should feel free to call Tables.partitions anywhere they're currently calling Tables.columns or Tables.rows, and get back an iterator of those instead. In other words, \"sink\" functions can use Tables.partitions whether or not the user passes a partionable table, since the default is to treat a single input as a single, non-partitioned table.\n\nTables.partitioner(itr) is a convenience wrapper to provide table partitions from any table iterator; this allows for easy wrapping of a Vector or iterator of tables as valid partitions, since by default, they'd be treated as a single table.\n\nA 2nd convenience method is provided with the definition:\n\nTables.partitions(x...) = x\n\nThat allows passing vararg tables and they'll be treated as separate partitions. Sink functions may allow vararg table inputs and can \"splat them through\" to partitions.\n\nFor convenience, Tables.partitions(x::Iterators.PartitionIterator) = x and Tables.partitions(x::Tables.Partitioner) = x are defined to handle cases where user created partitioning with the Iterators.partition or Tables.partitioner functions.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.partitioner-using-the-interface","page":"Using the Interface","title":"Tables.partitioner","text":"Tables.partitioner(f, itr)\nTables.partitioner(x)\n\nConvenience methods to generate table iterators. The first method takes a \"materializer\" function f and an iterator itr, and will call Tables.LazyTable(f, x) for x in itr for each iteration. This allows delaying table materialization until Tables.columns or Tables.rows are called on the LazyTable object (which will call f(x)). This allows a common desired pattern of materializing and processing a table on a remote process or thread, like:\n\nfor tbl in Tables.partitions(Tables.partitioner(CSV.File, list_of_csv_files))\n    Threads.@spawn begin\n        cols = Tables.columns(tbl)\n        # do stuff with cols\n    end\nend\n\nThe second method is provided because the default behavior of Tables.partition(x) is to treat x as a single, non-partitioned table. This method allows users to easily wrap a Vector or generator of tables as table partitions to pass to sink functions able to utilize Tables.partitions.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.rowtable-using-the-interface","page":"Using the Interface","title":"Tables.rowtable","text":"Tables.rowtable(x) => Vector{NamedTuple}\n\nTake any input table source, and produce a Vector of NamedTuples, also known as a \"row table\". A \"row table\" is a kind of default table type of sorts, since it satisfies the Tables.jl row interface naturally, i.e. a Vector naturally iterates its elements, and NamedTuple satisfies the AbstractRow interface by default (allows indexing value by index, name, and getting all names).\n\nFor a lazy iterator over rows see rows and namedtupleiterator.\n\nNot for use with extremely wide tables with # of columns > 67K; current fundamental compiler limits prevent constructing NamedTuples that large.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.columntable-using-the-interface","page":"Using the Interface","title":"Tables.columntable","text":"Tables.columntable(x) => NamedTuple of AbstractVectors\n\nTakes any input table source x and returns a NamedTuple of AbstractVectors, also known as a \"column table\". A \"column table\" is a kind of default table type of sorts, since it satisfies the Tables.jl column interface naturally.\n\nNote that if x is an object in which columns are stored as vectors, the check that these vectors use 1-based indexing is not performed (it should be ensured when x is constructed).\n\nNot for use with extremely wide tables with # of columns > 67K; current fundamental compiler limits prevent constructing NamedTuples that large.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.dictrowtable-using-the-interface","page":"Using the Interface","title":"Tables.dictrowtable","text":"Tables.dictrowtable(x) => Tables.DictRowTable\n\nTake any Tables.jl-compatible source x and return a DictRowTable, which can be thought of as a Vector of OrderedDict rows mapping column names as Symbols to values. The order of the input table columns is preserved via the Tables.schema(::DictRowTable).\n\nFor \"schema-less\" input tables, dictrowtable employs a \"column unioning\" behavior, as opposed to inferring the schema from the first row like Tables.columns. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value missing, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it's recommended to use only when the union behavior is needed.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.dictcolumntable-using-the-interface","page":"Using the Interface","title":"Tables.dictcolumntable","text":"Tables.dictcolumntable(x) => Tables.DictColumnTable\n\nTake any Tables.jl-compatible source x and return a DictColumnTable, which can be thought of as a OrderedDict mapping column names as Symbols to AbstractVectors. The order of the input table columns is preserved via the Tables.schema(::DictColumnTable).\n\nFor \"schema-less\" input tables, dictcolumntable employs a \"column unioning\" behavior, as opposed to inferring the schema from the first row like Tables.columns. This means that as rows are iterated, each value from the row is joined into an aggregate final set of columns. This is especially useful when input table rows may not include columns if the value is missing, instead of including an actual value missing, which is common in json, for example. This results in a performance cost tracking all seen values and inferring the final unioned schemas, so it's recommended to use only when needed.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.namedtupleiterator-using-the-interface","page":"Using the Interface","title":"Tables.namedtupleiterator","text":"Tables.namedtupleiterator(x)\n\nPass any table input source and return a NamedTuple iterator\n\nSee also rows and rowtable.\n\nNot for use with extremely wide tables with # of columns > 67K; current fundamental compiler limits prevent constructing NamedTuples that large.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.datavaluerows-using-the-interface","page":"Using the Interface","title":"Tables.datavaluerows","text":"Tables.datavaluerows(x) => NamedTuple iterator\n\nTakes any table input x and returns a NamedTuple iterator that will replace missing values with DataValue-wrapped values; this allows any table type to satisfy the TableTraits.jl  Queryverse integration interface by defining: \n\nIteratorInterfaceExtensions.getiterator(x::MyTable) = Tables.datavaluerows(x)\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.nondatavaluerows-using-the-interface","page":"Using the Interface","title":"Tables.nondatavaluerows","text":"Tables.nondatavaluerows(x)\n\nTakes any Queryverse-compatible NamedTuple iterator source and  converts to a Tables.jl-compatible AbstractRow iterator. Will automatically unwrap any DataValues, replacing NA with missing. Useful for translating Query.jl results back to non-DataValue-based tables.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.table-using-the-interface","page":"Using the Interface","title":"Tables.table","text":"Tables.table(m::AbstractVecOrMat; [header])\n\nWrap an AbstractVecOrMat (Matrix, Vector, Adjoint, etc.) in a MatrixTable, which satisfies the Tables.jl interface.  (An AbstractVector is treated as a 1-column matrix.) This allows accessing the matrix via Tables.rows and Tables.columns. An optional keyword argument iterator header can be passed which will be converted to a Vector{Symbol} to be used as the column names. Note that no copy of the AbstractVecOrMat is made.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.matrix-using-the-interface","page":"Using the Interface","title":"Tables.matrix","text":"Tables.matrix(table; transpose::Bool=false)\n\nMaterialize any table source input as a new Matrix or in the case of a MatrixTable return the originally wrapped matrix. If the table column element types are not homogeneous, they will be promoted to a common type in the materialized Matrix. Note that column names are ignored in the conversion. By default, input table columns will be materialized as corresponding matrix columns; passing transpose=true will transpose the input with input columns as matrix rows or in the case of a MatrixTable apply permutedims to the originally wrapped matrix.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.eachcolumn-using-the-interface","page":"Using the Interface","title":"Tables.eachcolumn","text":"Tables.eachcolumn(f, sch::Tables.Schema{names, types}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})\nTables.eachcolumn(f, sch::Tables.Schema{names, nothing}, x::Union{Tables.AbstractRow, Tables.AbstractColumns})\n\nTakes a function f, table schema sch, x, which is an object that satisfies the AbstractRow or AbstractColumns interfaces; it generates calls to get the value for each column (Tables.getcolumn(x, nm)) and then calls f(val, index, name), where f is the user-provided function, val is the column value (AbstractRow) or entire column (AbstractColumns), index is the column index as an Int, and name is the column name as a Symbol.\n\nAn example using Tables.eachcolumn is:\n\nrows = Tables.rows(tbl)\nsch = Tables.schema(rows)\nif sch === nothing\n    state = iterate(rows)\n    state === nothing && return\n    row, st = state\n    sch = Tables.schema(Tables.columnnames(row), nothing)\n    while state !== nothing\n        Tables.eachcolumn(sch, row) do val, i, nm\n            bind!(stmt, i, val)\n        end\n        state = iterate(rows, st)\n        state === nothing && return\n        row, st = state\n    end\nelse\n    for row in rows\n        Tables.eachcolumn(sch, row) do val, i, nm\n            bind!(stmt, i, val)\n        end\n    end\nend\n\nNote in this example we account for the input table potentially returning nothing from Tables.schema(rows); in that case, we start iterating the rows, and build a partial schema using the column names from the first row sch = Tables.schema(Tables.columnnames(row), nothing), which is valid to pass to Tables.eachcolumn.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.materializer-using-the-interface","page":"Using the Interface","title":"Tables.materializer","text":"Tables.materializer(x) => Callable\n\nFor a table input, return the \"sink\" function or \"materializing\" function that can take a Tables.jl-compatible table input and make an instance of the table type. This enables \"transform\" workflows that take table inputs, apply transformations, potentially converting the table to a different form, and end with producing a table of the same type as the original input. The default materializer is Tables.columntable, which converts any table input into a NamedTuple of Vectors.\n\nIt is recommended that for users implementing MyType, they define only materializer(::Type{<:MyType}). materializer(::MyType) will then automatically delegate to this method.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.columnindex-using-the-interface","page":"Using the Interface","title":"Tables.columnindex","text":"Tables.columnindex(table, name::Symbol)\n\nReturn the column index (1-based) of a column by name in a table with a known schema; returns 0 if name doesn't exist in table\n\n\n\n\n\ngiven names and a Symbol name, compute the index (1-based) of the name in names\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.columntype-using-the-interface","page":"Using the Interface","title":"Tables.columntype","text":"Tables.columntype(table, name::Symbol)\n\nReturn the column element type of a column by name in a table with a known schema; returns Union{} if name doesn't exist in table\n\n\n\n\n\ngiven tuple type and a Symbol name, compute the type of the name in the tuples types\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.rowmerge-using-the-interface","page":"Using the Interface","title":"Tables.rowmerge","text":"rowmerge(row, other_rows...)\nrowmerge(row; fields_to_merge...)\n\nReturn a NamedTuple by merging row (an AbstractRow-compliant value) with other_rows (one or more AbstractRow-compliant values) via Base.merge. This function is similar to Base.merge(::NamedTuple, ::NamedTuple...), but accepts AbstractRow-compliant values instead of NamedTuples.\n\nA convenience method rowmerge(row; fields_to_merge...) = rowmerge(row, fields_to_merge) is defined that enables the fields_to_merge to be specified as keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"using-the-interface/#Tables.Row-using-the-interface","page":"Using the Interface","title":"Tables.Row","text":"Tables.Row(row)\n\nConvenience type to wrap any AbstractRow interface object in a dedicated struct to provide useful default behaviors (allows any AbstractRow to be used like a NamedTuple):\n\nIndexing interface defined; i.e. row[i] will return the column value at index i, row[nm] will return column value for column name nm\nProperty access interface defined; i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column value in the row\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving column values\n\n\n\n\n\n","category":"type"},{"location":"using-the-interface/#Tables.Columns-using-the-interface","page":"Using the Interface","title":"Tables.Columns","text":"Tables.Columns(tbl)\n\nConvenience type that calls Tables.columns on an input tbl and wraps the resulting AbstractColumns interface object in a dedicated struct to provide useful default behaviors (allows any AbstractColumns to be used like a NamedTuple of Vectors):\n\nIndexing interface defined; i.e. row[i] will return the column at index i, row[nm] will return column for column name nm\nProperty access interface defined; i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column in the row\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving columns\n\nNote that Tables.Columns calls Tables.columns internally on the provided table argument. Tables.Columns can be used for dispatch if needed.\n\n\n\n\n\n","category":"type"},{"location":"implementing-the-interface/#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)","page":"Implementing the Interface","title":"Implementing the Interface (i.e. becoming a Tables.jl source)","text":"","category":"section"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Now that we've seen how one uses the Tables.jl interface, let's walk-through how to implement it; i.e. how can I make my custom type valid for Tables.jl consumers?","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"For a type MyTable, the interface to becoming a proper table is straightforward:","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Required Methods Default Definition Brief Description\nTables.istable(::Type{MyTable})  Declare that your table type implements the interface\nOne of:  \nTables.rowaccess(::Type{MyTable})  Declare that your table type defines a Tables.rows(::MyTable) method\nTables.rows(x::MyTable)  Return an Tables.AbstractRow-compatible iterator from your table\nOr:  \nTables.columnaccess(::Type{MyTable})  Declare that your table type defines a Tables.columns(::MyTable) method\nTables.columns(x::MyTable)  Return an Tables.AbstractColumns-compatible object from your table\nOptional methods  \nTables.schema(x::MyTable) Tables.schema(x) = nothing Return a Tables.Schema object from your Tables.AbstractRow iterator or Tables.AbstractColumns object; or nothing for unknown schema\nTables.materializer(::Type{MyTable}) Tables.columntable Declare a \"materializer\" sink function for your table type that can construct an instance of your type from any Tables.jl input\nTables.subset(x::MyTable, inds; viewhint)  Return a row or a sub-table of the original table\nDataAPI.nrow(x::MyTable)  Return number of rows of table x\nDataAPI.ncol(x::MyTable)  Return number of columns of table x","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Based on whether your table type has defined Tables.rows or Tables.columns, you then ensure that the Tables.AbstractRow iterator or Tables.AbstractColumns object satisfies the respective interface.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"As an additional source of documentation, see this discourse post outlining in detail a walk-through of making a row-oriented table.","category":"page"},{"location":"implementing-the-interface/#Tables.AbstractRow","page":"Implementing the Interface","title":"Tables.AbstractRow","text":"","category":"section"},{"location":"implementing-the-interface/#Tables.AbstractRow-implementing-the-interface","page":"Implementing the Interface","title":"Tables.AbstractRow","text":"Tables.AbstractRow\n\nAbstract interface type representing the expected eltype of the iterator returned from Tables.rows(table). Tables.rows must return an iterator of elements that satisfy the Tables.AbstractRow interface. While Tables.AbstractRow is an abstract type that custom \"row\" types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects are not required to subtype, but only implement the required interface methods.\n\nInterface definition:\n\nRequired Methods Default Definition Brief Description\nTables.getcolumn(row, i::Int) getfield(row, i) Retrieve a column value by index\nTables.getcolumn(row, nm::Symbol) getproperty(row, nm) Retrieve a column value by name\nTables.columnnames(row) propertynames(row) Return column names for a row as a 1-based indexable collection\nOptional methods  \nTables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol) Tables.getcolumn(row, nm) Given a column element type T, index i, and column name nm, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency.\n\nNote that subtypes of Tables.AbstractRow must overload all required methods listed above instead of relying on these methods' default definitions.\n\nWhile custom row types aren't required to subtype Tables.AbstractRow, benefits of doing so include:\n\nIndexing interface defined (using getcolumn); i.e. row[i] will return the column value at index i\nProperty access interface defined (using columnnames and getcolumn); i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column value in the row\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving column values\nA default show method\n\nThis allows the custom row type to behave as close as possible to a builtin NamedTuple object.\n\n\n\n\n\n","category":"type"},{"location":"implementing-the-interface/#Tables.AbstractColumns","page":"Implementing the Interface","title":"Tables.AbstractColumns","text":"","category":"section"},{"location":"implementing-the-interface/#Tables.AbstractColumns-implementing-the-interface","page":"Implementing the Interface","title":"Tables.AbstractColumns","text":"Tables.AbstractColumns\n\nAn interface type defined as an ordered set of columns that support retrieval of individual columns by name or index. A retrieved column must be a 1-based indexable collection with known length, i.e. an object that supports length(col) and col[i] for any i = 1:length(col). Tables.columns must return an object that satisfies the Tables.AbstractColumns interface. While Tables.AbstractColumns is an abstract type that custom \"columns\" types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects are not required to subtype, but only implement the required interface methods.\n\nInterface definition:\n\nRequired Methods Default Definition Brief Description\nTables.getcolumn(table, i::Int) getfield(table, i) Retrieve a column by index\nTables.getcolumn(table, nm::Symbol) getproperty(table, nm) Retrieve a column by name\nTables.columnnames(table) propertynames(table) Return column names for a table as a 1-based indexable collection\nOptional methods  \nTables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol) Tables.getcolumn(table, nm) Given a column eltype T, index i, and column name nm, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency.\n\nNote that subtypes of Tables.AbstractColumns must overload all required methods listed above instead of relying on these methods' default definitions.\n\nWhile types aren't required to subtype Tables.AbstractColumns, benefits of doing so include:\n\nIndexing interface defined (using getcolumn); i.e. tbl[i] will retrieve the column at index i\nProperty access interface defined (using columnnames and getcolumn); i.e. tbl.col1 will retrieve column named col1\nIteration interface defined; i.e. for col in table will iterate each column in the table\nAbstractDict methods defined (get, haskey, etc.) for checking and retrieving columns\nA default show method\n\nThis allows a custom table type to behave as close as possible to a builtin NamedTuple of vectors object.\n\n\n\n\n\n","category":"type"},{"location":"implementing-the-interface/#Implementation-Example","page":"Implementing the Interface","title":"Implementation Example","text":"","category":"section"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"As an extended example, let's take a look at some code defined in Tables.jl for treating AbstractVecOrMats as tables.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"First, we define a special MatrixTable type that will wrap an AbstractVecOrMat, and allow easy overloading for the Tables.jl interface.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"struct MatrixTable{T <: AbstractVecOrMat} <: Tables.AbstractColumns\n    names::Vector{Symbol}\n    lookup::Dict{Symbol, Int}\n    matrix::T\nend\n# declare that MatrixTable is a table\nTables.istable(::Type{<:MatrixTable}) = true\n# getter methods to avoid getproperty clash\nnames(m::MatrixTable) = getfield(m, :names)\nmatrix(m::MatrixTable) = getfield(m, :matrix)\nlookup(m::MatrixTable) = getfield(m, :lookup)\n# schema is column names and types\nTables.schema(m::MatrixTable{T}) where {T} = Tables.Schema(names(m), fill(eltype(T), size(matrix(m), 2)))","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Here we defined Tables.istable for all MatrixTable types, signaling that they implement the Tables.jl interfaces. We also defined Tables.schema by pulling the column names out that we stored, and since AbstractVecOrMat have a single eltype, we repeat it for each column (the call to fill). Note that defining Tables.schema is optional on tables; by default, nothing is returned and Tables.jl consumers should account for both known and unknown schema cases. Returning a schema when possible allows consumers to have certain optimizations when they can know the types of all columns upfront (and if the # of columns isn't too large) to generate more efficient code.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Now, in this example, we're actually going to have MatrixTable implement both Tables.rows and Tables.columns methods itself, i.e. it's going to return itself from those functions, so here's first how we make our MatrixTable a valid Tables.AbstractColumns object:","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"# column interface\nTables.columnaccess(::Type{<:MatrixTable}) = true\nTables.columns(m::MatrixTable) = m\n# required Tables.AbstractColumns object methods\nTables.getcolumn(m::MatrixTable, ::Type{T}, col::Int, nm::Symbol) where {T} = matrix(m)[:, col]\nTables.getcolumn(m::MatrixTable, nm::Symbol) = matrix(m)[:, lookup(m)[nm]]\nTables.getcolumn(m::MatrixTable, i::Int) = matrix(m)[:, i]\nTables.columnnames(m::MatrixTable) = names(m)","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"We define columnaccess for our type, then columns just returns the MatrixTable itself, and then we define the three getcolumn methods and columnnames. Note the use of a lookup Dict that maps column name to column index so we can figure out which column to return from the matrix. We're also storing the column names in our names field so the columnnames implementation is trivial. And that's it! Literally! It can now be written out to a csv file, stored in a sqlite or other database, converted to DataFrame or JuliaDB table, etc. Pretty fun.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"And now for the Tables.rows implementation:","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"# declare that any MatrixTable defines its own `Tables.rows` method\nrowaccess(::Type{<:MatrixTable}) = true\n# just return itself, which means MatrixTable must iterate `Tables.AbstractRow`-compatible objects\nrows(m::MatrixTable) = m\n# the iteration interface, at a minimum, requires `eltype`, `length`, and `iterate`\n# for `MatrixTable` `eltype`, we're going to provide a custom row type\nBase.eltype(m::MatrixTable{T}) where {T} = MatrixRow{T}\nBase.length(m::MatrixTable) = size(matrix(m), 1)\n\nBase.iterate(m::MatrixTable, st=1) = st > length(m) ? nothing : (MatrixRow(st, m), st + 1)\n\n# a custom row type; acts as a \"view\" into a row of an AbstractVecOrMat\nstruct MatrixRow{T} <: Tables.AbstractRow\n    row::Int\n    source::MatrixTable{T}\nend\n# required `Tables.AbstractRow` interface methods (same as for `Tables.AbstractColumns` object before)\n# but this time, on our custom row type\ngetcolumn(m::MatrixRow, ::Type, col::Int, nm::Symbol) =\n    getfield(getfield(m, :source), :matrix)[getfield(m, :row), col]\ngetcolumn(m::MatrixRow, i::Int) =\n    getfield(getfield(m, :source), :matrix)[getfield(m, :row), i]\ngetcolumn(m::MatrixRow, nm::Symbol) =\n    getfield(getfield(m, :source), :matrix)[getfield(m, :row), getfield(getfield(m, :source), :lookup)[nm]]\ncolumnnames(m::MatrixRow) = names(getfield(m, :source))","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Here we start by defining Tables.rowaccess and Tables.rows, and then the iteration interface methods, since we declared that a MatrixTable itself is an iterator of Tables.AbstractRow-compatible objects. For eltype, we say that a MatrixTable iterates our own custom row type, MatrixRow. MatrixRow subtypes Tables.AbstractRow, which provides interface implementations for several useful behaviors (indexing, iteration, property-access, etc.); essentially it makes our custom MatrixRow type more convenient to work with.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Implementing the Tables.AbstractRow interface is straightforward, and very similar to our implementation of Tables.AbstractColumns previously (i.e. the same methods for getcolumn and columnnames).","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"And that's it. Our MatrixTable type is now a fully fledged, valid Tables.jl source and can be used throughout the ecosystem. Now, this is obviously not a lot of code; but then again, the actual Tables.jl interface implementations tend to be fairly simple, given the other behaviors that are already defined for table types (i.e. table types tend to already have a getcolumn like function defined).","category":"page"},{"location":"implementing-the-interface/#Tables.isrowtable","page":"Implementing the Interface","title":"Tables.isrowtable","text":"","category":"section"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"One option for certain table types is to define Tables.isrowtable to automatically satisfy the Tables.jl interface. This can be convenient for \"natural\" table types that already iterate rows.","category":"page"},{"location":"implementing-the-interface/#Tables.isrowtable-implementing-the-interface","page":"Implementing the Interface","title":"Tables.isrowtable","text":"Tables.isrowtable(x) => Bool\n\nFor convenience, some table objects that are naturally \"row oriented\" can define Tables.isrowtable(::Type{TableType}) = true to simplify satisfying the Tables.jl interface. Requirements for defining isrowtable include:\n\nTables.rows(x) === x, i.e. the table object itself is a Row iterator\nIf the table object is mutable, it should support:\npush!(x, row): allow pushing a single row onto table\nappend!(x, rows): allow appending set of rows onto table\nIf table object is mutable and indexable, it should support:\nx[i] = row: allow replacing of a row with another row by index\n\nA table object that defines Tables.isrowtable will have definitions for Tables.istable, Tables.rowaccess, and Tables.rows automatically defined.\n\n\n\n\n\n","category":"function"},{"location":"implementing-the-interface/#Testing-Tables.jl-Implementations","page":"Implementing the Interface","title":"Testing Tables.jl Implementations","text":"","category":"section"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"One question that comes up is what the best strategies are for testing a Tables.jl implementation. Continuing with our MatrixTable example, let's see some useful ways to test that things are working as expected.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"mat = [1 4.0 \"7\"; 2 5.0 \"8\"; 3 6.0 \"9\"]","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"First, we define a matrix literal with three columns of various differently typed values.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"# first, create a MatrixTable from our matrix input\nmattbl = Tables.table(mat)\n# test that the MatrixTable `istable`\n@test Tables.istable(typeof(mattbl))\n# test that it defines row access\n@test Tables.rowaccess(typeof(mattbl))\n@test Tables.rows(mattbl) === mattbl\n# test that it defines column access\n@test Tables.columnaccess(typeof(mattbl))\n@test Tables.columns(mattbl) === mattbl\n# test that we can access the first \"column\" of our matrix table by column name\n@test mattbl.Column1 == [1,2,3]\n# test our `Tables.AbstractColumns` interface methods\n@test Tables.getcolumn(mattbl, :Column1) == [1,2,3]\n@test Tables.getcolumn(mattbl, 1) == [1,2,3]\n@test Tables.columnnames(mattbl) == [:Column1, :Column2, :Column3]\n# now let's iterate our MatrixTable to get our first MatrixRow\nmatrow = first(mattbl)\n@test eltype(mattbl) == typeof(matrow)\n# now we can test our `Tables.AbstractRow` interface methods on our MatrixRow\n@test matrow.Column1 == 1\n@test Tables.getcolumn(matrow, :Column1) == 1\n@test Tables.getcolumn(matrow, 1) == 1\n@test propertynames(mattbl) == propertynames(matrow) == [:Column1, :Column2, :Column3]","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"So, it looks like our MatrixTable type is looking good. It's doing everything we'd expect with regards to accessing its rows or columns via the Tables.jl API methods. Testing a table source like this is fairly straightforward since we're really just testing that our interface methods are doing what we expect them to do.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Now, while we didn't go over a \"sink\" function for matrices in our walkthrough, there does indeed exist a Tables.matrix function that allows converting any table input source into a plain Julia Matrix object.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"Having both Tables.jl \"source\" and \"sink\" implementations (i.e. a type that is a Tables.jl-compatible source, as well as a way to consume other tables), allows us to do some additional \"round trip\" testing:","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"rt = [(a=1, b=4.0, c=\"7\"), (a=2, b=5.0, c=\"8\"), (a=3, b=6.0, c=\"9\")]\nct = (a=[1,2,3], b=[4.0, 5.0, 6.0])","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"In addition to our mat object earlier, we can define a couple simple \"tables\"; in this case rt is a kind of default \"row table\" as a Vector of NamedTuples, while ct is a default \"column table\" as a NamedTuple of Vectors. Notice that they contain mostly the same data as our matrix literal earlier, yet in slightly different storage formats. These default \"row\" and \"column\" tables are supported by default in Tables.jl due do their natural table representations, and hence can be excellent tools in testing table integrations.","category":"page"},{"location":"implementing-the-interface/","page":"Implementing the Interface","title":"Implementing the Interface","text":"# let's turn our row table into a plain Julia Matrix object\nmat = Tables.matrix(rt)\n# test that our matrix came out like we expected\n@test mat[:, 1] == [1, 2, 3]\n@test size(mat) == (3, 3)\n@test eltype(mat) == Any\n# so we successfully consumed a row-oriented table,\n# now let's try with a column-oriented table\nmat2 = Tables.matrix(ct)\n@test eltype(mat2) == Float64\n@test mat2[:, 1] == ct.a\n\n# now let's take our matrix input, and make a column table out of it\ntbl = Tables.table(mat) |> columntable\n@test keys(tbl) == (:Column1, :Column2, :Column3)\n@test tbl.Column1 == [1, 2, 3]\n# and same for a row table\ntbl2 = Tables.table(mat2) |> rowtable\n@test length(tbl2) == 3\n@test map(x->x.Column1, tbl2) == [1.0, 2.0, 3.0]","category":"page"},{"location":"#Tables.jl-Documentation","page":"Home","title":"Tables.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This guide provides documentation around the powerful tables interfaces in the Tables.jl package. Note that the package, and hence, documentation, are geared towards package and library developers who intend to implement and consume the interfaces. Users, on the other hand, benefit from these other packages that provide useful access to table data in various formats or workflows. While everyone is encouraged to understand the interfaces and the functionality they allow, just note that most users don't need to use Tables.jl directly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With that said, don't hesitate to open a new issue, even just for a question, or come chat with us on the #data slack channel with questions, concerns, or clarifications. Also one can find list of packages that supports Tables.jl interface in INTEGRATIONS.md.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please refer to TableOperations.jl for common table operations such as  select, transform, filter and  map and to TableTransforms.jl for more sophisticated transformations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Depth = 3\nPages = [\n    \"index.md\",\n    \"using-the-interface.md\",\n    \"implementing-the-interface.md\",\n    \"api.md\",\n]","category":"page"}]
}
