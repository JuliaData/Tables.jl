<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementing the Interface · Tables.jl</title><meta name="title" content="Implementing the Interface · Tables.jl"/><meta property="og:title" content="Implementing the Interface · Tables.jl"/><meta property="twitter:title" content="Implementing the Interface · Tables.jl"/><meta name="description" content="Documentation for Tables.jl."/><meta property="og:description" content="Documentation for Tables.jl."/><meta property="twitter:description" content="Documentation for Tables.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Tables.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../using-the-interface/">Using the Interface</a></li><li class="is-active"><a class="tocitem" href>Implementing the Interface</a><ul class="internal"><li><a class="tocitem" href="#Tables.AbstractRow"><span><code>Tables.AbstractRow</code></span></a></li><li><a class="tocitem" href="#Tables.AbstractColumns"><span><code>Tables.AbstractColumns</code></span></a></li><li><a class="tocitem" href="#Implementation-Example"><span>Implementation Example</span></a></li><li><a class="tocitem" href="#Tables.isrowtable"><span><code>Tables.isrowtable</code></span></a></li><li><a class="tocitem" href="#Testing-Tables.jl-Implementations"><span>Testing Tables.jl Implementations</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementing the Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementing the Interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaData/Tables.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaData/Tables.jl/blob/main/docs/src/implementing-the-interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)"><a class="docs-heading-anchor" href="#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)">Implementing the Interface (i.e. becoming a Tables.jl source)</a><a id="Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)" title="Permalink"></a></h1><p>Now that we&#39;ve seen how one <em>uses</em> the Tables.jl interface, let&#39;s walk-through how to implement it; i.e. how can I make my custom type valid for Tables.jl consumers?</p><p>For a type <code>MyTable</code>, the interface to becoming a proper table is straightforward:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.istable(::Type{MyTable})</code></td><td style="text-align: right"></td><td style="text-align: right">Declare that your table type implements the interface</td></tr><tr><td style="text-align: right"><strong>One of:</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.rowaccess(::Type{MyTable})</code></td><td style="text-align: right"></td><td style="text-align: right">Declare that your table type defines a <code>Tables.rows(::MyTable)</code> method</td></tr><tr><td style="text-align: right"><code>Tables.rows(x::MyTable)</code></td><td style="text-align: right"></td><td style="text-align: right">Return an <code>Tables.AbstractRow</code>-compatible iterator from your table</td></tr><tr><td style="text-align: right"><strong>Or:</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.columnaccess(::Type{MyTable})</code></td><td style="text-align: right"></td><td style="text-align: right">Declare that your table type defines a <code>Tables.columns(::MyTable)</code> method</td></tr><tr><td style="text-align: right"><code>Tables.columns(x::MyTable)</code></td><td style="text-align: right"></td><td style="text-align: right">Return an <code>Tables.AbstractColumns</code>-compatible object from your table</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.schema(x::MyTable)</code></td><td style="text-align: right"><code>Tables.schema(x) = nothing</code></td><td style="text-align: right">Return a <a href="../api/#Tables.Schema"><code>Tables.Schema</code></a> object from your <code>Tables.AbstractRow</code> iterator or <code>Tables.AbstractColumns</code> object; or <code>nothing</code> for unknown schema</td></tr><tr><td style="text-align: right"><code>Tables.materializer(::Type{MyTable})</code></td><td style="text-align: right"><code>Tables.columntable</code></td><td style="text-align: right">Declare a &quot;materializer&quot; sink function for your table type that can construct an instance of your type from any Tables.jl input</td></tr><tr><td style="text-align: right"><code>Tables.subset(x::MyTable, inds; viewhint)</code></td><td style="text-align: right"></td><td style="text-align: right">Return a row or a sub-table of the original table</td></tr><tr><td style="text-align: right"><code>DataAPI.nrow(x::MyTable)</code></td><td style="text-align: right"></td><td style="text-align: right">Return number of rows of table <code>x</code></td></tr><tr><td style="text-align: right"><code>DataAPI.ncol(x::MyTable)</code></td><td style="text-align: right"></td><td style="text-align: right">Return number of columns of table <code>x</code></td></tr></table><p>Based on whether your table type has defined <code>Tables.rows</code> or <code>Tables.columns</code>, you then ensure that the <code>Tables.AbstractRow</code> iterator or <code>Tables.AbstractColumns</code> object satisfies the respective interface.</p><p>As an additional source of documentation, see <a href="https://discourse.julialang.org/t/struggling-to-implement-tables-jl-interface-for-vector-mystruct/42318/7?u=quinnj">this discourse post</a> outlining in detail a walk-through of making a row-oriented table.</p><h2 id="Tables.AbstractRow"><a class="docs-heading-anchor" href="#Tables.AbstractRow"><code>Tables.AbstractRow</code></a><a id="Tables.AbstractRow-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.AbstractRow" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.AbstractRow-implementing-the-interface" href="#Tables.AbstractRow-implementing-the-interface"><code>Tables.AbstractRow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.AbstractRow</code></pre><p>Abstract interface type representing the expected <code>eltype</code> of the iterator returned from <code>Tables.rows(table)</code>. <code>Tables.rows</code> must return an iterator of elements that satisfy the <code>Tables.AbstractRow</code> interface. While <code>Tables.AbstractRow</code> is an abstract type that custom &quot;row&quot; types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects <strong>are not required</strong> to subtype, but only implement the required interface methods.</p><p>Interface definition:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, i::Int)</code></td><td style="text-align: right"><code>getfield(row, i)</code></td><td style="text-align: right">Retrieve a column value by index</td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, nm::Symbol)</code></td><td style="text-align: right"><code>getproperty(row, nm)</code></td><td style="text-align: right">Retrieve a column value by name</td></tr><tr><td style="text-align: right"><code>Tables.columnnames(row)</code></td><td style="text-align: right"><code>propertynames(row)</code></td><td style="text-align: right">Return column names for a row as a 1-based indexable collection</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol)</code></td><td style="text-align: right"><code>Tables.getcolumn(row, nm)</code></td><td style="text-align: right">Given a column element type <code>T</code>, index <code>i</code>, and column name <code>nm</code>, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency.</td></tr></table><p>Note that subtypes of <code>Tables.AbstractRow</code> <strong>must</strong> overload all required methods listed above instead of relying on these methods&#39; default definitions.</p><p>While custom row types aren&#39;t required to subtype <code>Tables.AbstractRow</code>, benefits of doing so include:</p><ul><li>Indexing interface defined (using <code>getcolumn</code>); i.e. <code>row[i]</code> will return the column value at index <code>i</code></li><li>Property access interface defined (using <code>columnnames</code> and <code>getcolumn</code>); i.e. <code>row.col1</code> will retrieve the value for the column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for x in row</code> will iterate each column value in the row</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving column values</li><li>A default <code>show</code> method</li></ul><p>This allows the custom row type to behave as close as possible to a builtin <code>NamedTuple</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L49-L79">source</a></section></article><h2 id="Tables.AbstractColumns"><a class="docs-heading-anchor" href="#Tables.AbstractColumns"><code>Tables.AbstractColumns</code></a><a id="Tables.AbstractColumns-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.AbstractColumns" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.AbstractColumns-implementing-the-interface" href="#Tables.AbstractColumns-implementing-the-interface"><code>Tables.AbstractColumns</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.AbstractColumns</code></pre><p>An interface type defined as an ordered set of columns that support retrieval of individual columns by name or index. A retrieved column must be a 1-based indexable collection with known length, i.e. an object that supports <code>length(col)</code> and <code>col[i]</code> for any <code>i = 1:length(col)</code>. <code>Tables.columns</code> must return an object that satisfies the <code>Tables.AbstractColumns</code> interface. While <code>Tables.AbstractColumns</code> is an abstract type that custom &quot;columns&quot; types may subtype for useful default behavior (indexing, iteration, property-access, etc.), users should not use it for dispatch, as Tables.jl interface objects <strong>are not required</strong> to subtype, but only implement the required interface methods.</p><p>Interface definition:</p><table><tr><th style="text-align: right">Required Methods</th><th style="text-align: right">Default Definition</th><th style="text-align: right">Brief Description</th></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, i::Int)</code></td><td style="text-align: right"><code>getfield(table, i)</code></td><td style="text-align: right">Retrieve a column by index</td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, nm::Symbol)</code></td><td style="text-align: right"><code>getproperty(table, nm)</code></td><td style="text-align: right">Retrieve a column by name</td></tr><tr><td style="text-align: right"><code>Tables.columnnames(table)</code></td><td style="text-align: right"><code>propertynames(table)</code></td><td style="text-align: right">Return column names for a table as a 1-based indexable collection</td></tr><tr><td style="text-align: right"><strong>Optional methods</strong></td><td style="text-align: right"></td><td style="text-align: right"></td></tr><tr><td style="text-align: right"><code>Tables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol)</code></td><td style="text-align: right"><code>Tables.getcolumn(table, nm)</code></td><td style="text-align: right">Given a column eltype <code>T</code>, index <code>i</code>, and column name <code>nm</code>, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency.</td></tr></table><p>Note that subtypes of <code>Tables.AbstractColumns</code> <strong>must</strong> overload all required methods listed above instead of relying on these methods&#39; default definitions.</p><p>While types aren&#39;t required to subtype <code>Tables.AbstractColumns</code>, benefits of doing so include:</p><ul><li>Indexing interface defined (using <code>getcolumn</code>); i.e. <code>tbl[i]</code> will retrieve the column at index <code>i</code></li><li>Property access interface defined (using <code>columnnames</code> and <code>getcolumn</code>); i.e. <code>tbl.col1</code> will retrieve column named <code>col1</code></li><li>Iteration interface defined; i.e. <code>for col in table</code> will iterate each column in the table</li><li><code>AbstractDict</code> methods defined (<code>get</code>, <code>haskey</code>, etc.) for checking and retrieving columns</li><li>A default <code>show</code> method</li></ul><p>This allows a custom table type to behave as close as possible to a builtin <code>NamedTuple</code> of vectors object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L13-L46">source</a></section></article><h2 id="Implementation-Example"><a class="docs-heading-anchor" href="#Implementation-Example">Implementation Example</a><a id="Implementation-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Example" title="Permalink"></a></h2><p>As an extended example, let&#39;s take a look at some code defined in Tables.jl for treating <code>AbstractVecOrMat</code>s as tables.</p><p>First, we define a special <code>MatrixTable</code> type that will wrap an <code>AbstractVecOrMat</code>, and allow easy overloading for the Tables.jl interface.</p><pre><code class="language-julia hljs">struct MatrixTable{T &lt;: AbstractVecOrMat} &lt;: Tables.AbstractColumns
    names::Vector{Symbol}
    lookup::Dict{Symbol, Int}
    matrix::T
end
# declare that MatrixTable is a table
Tables.istable(::Type{&lt;:MatrixTable}) = true
# getter methods to avoid getproperty clash
names(m::MatrixTable) = getfield(m, :names)
matrix(m::MatrixTable) = getfield(m, :matrix)
lookup(m::MatrixTable) = getfield(m, :lookup)
# schema is column names and types
Tables.schema(m::MatrixTable{T}) where {T} = Tables.Schema(names(m), fill(eltype(T), size(matrix(m), 2)))</code></pre><p>Here we defined <code>Tables.istable</code> for all <code>MatrixTable</code> types, signaling that they implement the Tables.jl interfaces. We also defined <a href="../api/#Tables.schema"><code>Tables.schema</code></a> by pulling the column names out that we stored, and since <code>AbstractVecOrMat</code> have a single <code>eltype</code>, we repeat it for each column (the call to <code>fill</code>). Note that defining <a href="../api/#Tables.schema"><code>Tables.schema</code></a> is optional on tables; by default, <code>nothing</code> is returned and Tables.jl consumers should account for both known and unknown schema cases. Returning a schema when possible allows consumers to have certain optimizations when they can know the types of all columns upfront (and if the # of columns isn&#39;t too large) to generate more efficient code.</p><p>Now, in this example, we&#39;re actually going to have <code>MatrixTable</code> implement <em>both</em> <code>Tables.rows</code> and <code>Tables.columns</code> methods itself, i.e. it&#39;s going to return itself from those functions, so here&#39;s first how we make our <code>MatrixTable</code> a valid <code>Tables.AbstractColumns</code> object:</p><pre><code class="language-julia hljs"># column interface
Tables.columnaccess(::Type{&lt;:MatrixTable}) = true
Tables.columns(m::MatrixTable) = m
# required Tables.AbstractColumns object methods
Tables.getcolumn(m::MatrixTable, ::Type{T}, col::Int, nm::Symbol) where {T} = matrix(m)[:, col]
Tables.getcolumn(m::MatrixTable, nm::Symbol) = matrix(m)[:, lookup(m)[nm]]
Tables.getcolumn(m::MatrixTable, i::Int) = matrix(m)[:, i]
Tables.columnnames(m::MatrixTable) = names(m)</code></pre><p>We define <code>columnaccess</code> for our type, then <code>columns</code> just returns the <code>MatrixTable</code> itself, and then we define the three <code>getcolumn</code> methods and <code>columnnames</code>. Note the use of a <code>lookup</code> <code>Dict</code> that maps column name to column index so we can figure out which column to return from the matrix. We&#39;re also storing the column names in our <code>names</code> field so the <code>columnnames</code> implementation is trivial. And that&#39;s it! Literally! It can now be written out to a csv file, stored in a sqlite or other database, converted to DataFrame or JuliaDB table, etc. Pretty fun.</p><p>And now for the <code>Tables.rows</code> implementation:</p><pre><code class="language-julia hljs"># declare that any MatrixTable defines its own `Tables.rows` method
rowaccess(::Type{&lt;:MatrixTable}) = true
# just return itself, which means MatrixTable must iterate `Tables.AbstractRow`-compatible objects
rows(m::MatrixTable) = m
# the iteration interface, at a minimum, requires `eltype`, `length`, and `iterate`
# for `MatrixTable` `eltype`, we&#39;re going to provide a custom row type
Base.eltype(m::MatrixTable{T}) where {T} = MatrixRow{T}
Base.length(m::MatrixTable) = size(matrix(m), 1)

Base.iterate(m::MatrixTable, st=1) = st &gt; length(m) ? nothing : (MatrixRow(st, m), st + 1)

# a custom row type; acts as a &quot;view&quot; into a row of an AbstractVecOrMat
struct MatrixRow{T} &lt;: Tables.AbstractRow
    row::Int
    source::MatrixTable{T}
end
# required `Tables.AbstractRow` interface methods (same as for `Tables.AbstractColumns` object before)
# but this time, on our custom row type
getcolumn(m::MatrixRow, ::Type, col::Int, nm::Symbol) =
    getfield(getfield(m, :source), :matrix)[getfield(m, :row), col]
getcolumn(m::MatrixRow, i::Int) =
    getfield(getfield(m, :source), :matrix)[getfield(m, :row), i]
getcolumn(m::MatrixRow, nm::Symbol) =
    getfield(getfield(m, :source), :matrix)[getfield(m, :row), getfield(getfield(m, :source), :lookup)[nm]]
columnnames(m::MatrixRow) = names(getfield(m, :source))</code></pre><p>Here we start by defining <code>Tables.rowaccess</code> and <code>Tables.rows</code>, and then the iteration interface methods, since we declared that a <code>MatrixTable</code> itself is an iterator of <code>Tables.AbstractRow</code>-compatible objects. For <code>eltype</code>, we say that a <code>MatrixTable</code> iterates our own custom row type, <code>MatrixRow</code>. <code>MatrixRow</code> subtypes <code>Tables.AbstractRow</code>, which provides interface implementations for several useful behaviors (indexing, iteration, property-access, etc.); essentially it makes our custom <code>MatrixRow</code> type more convenient to work with.</p><p>Implementing the <code>Tables.AbstractRow</code> interface is straightforward, and very similar to our implementation of <code>Tables.AbstractColumns</code> previously (i.e. the same methods for <code>getcolumn</code> and <code>columnnames</code>).</p><p>And that&#39;s it. Our <code>MatrixTable</code> type is now a fully fledged, valid Tables.jl source and can be used throughout the ecosystem. Now, this is obviously not a lot of code; but then again, the actual Tables.jl interface implementations tend to be fairly simple, given the other behaviors that are already defined for table types (i.e. table types tend to already have a <code>getcolumn</code> like function defined).</p><h2 id="Tables.isrowtable"><a class="docs-heading-anchor" href="#Tables.isrowtable"><code>Tables.isrowtable</code></a><a id="Tables.isrowtable-1"></a><a class="docs-heading-anchor-permalink" href="#Tables.isrowtable" title="Permalink"></a></h2><p>One option for certain table types is to define <code>Tables.isrowtable</code> to automatically satisfy the Tables.jl interface. This can be convenient for &quot;natural&quot; table types that already iterate rows.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tables.isrowtable-implementing-the-interface" href="#Tables.isrowtable-implementing-the-interface"><code>Tables.isrowtable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Tables.isrowtable(x) =&gt; Bool</code></pre><p>For convenience, some table objects that are naturally &quot;row oriented&quot; can define <code>Tables.isrowtable(::Type{TableType}) = true</code> to simplify satisfying the Tables.jl interface. Requirements for defining <code>isrowtable</code> include:</p><ul><li><code>Tables.rows(x) === x</code>, i.e. the table object itself is a <code>Row</code> iterator</li><li>If the table object is mutable, it should support:<ul><li><code>push!(x, row)</code>: allow pushing a single row onto table</li><li><code>append!(x, rows)</code>: allow appending set of rows onto table</li></ul></li><li>If table object is mutable and indexable, it should support:<ul><li><code>x[i] = row</code>: allow replacing of a row with another row by index</li></ul></li></ul><p>A table object that defines <code>Tables.isrowtable</code> will have definitions for <code>Tables.istable</code>, <code>Tables.rowaccess</code>, and <code>Tables.rows</code> automatically defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaData/Tables.jl/blob/06abc194d0cb0d245859d163258a6d5723898c9d/src/Tables.jl#L118-L133">source</a></section></article><h2 id="Testing-Tables.jl-Implementations"><a class="docs-heading-anchor" href="#Testing-Tables.jl-Implementations">Testing Tables.jl Implementations</a><a id="Testing-Tables.jl-Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Tables.jl-Implementations" title="Permalink"></a></h2><p>One question that comes up is what the best strategies are for testing a Tables.jl implementation. Continuing with our <code>MatrixTable</code> example, let&#39;s see some useful ways to test that things are working as expected.</p><pre><code class="language-julia hljs">mat = [1 4.0 &quot;7&quot;; 2 5.0 &quot;8&quot;; 3 6.0 &quot;9&quot;]</code></pre><p>First, we define a matrix literal with three columns of various differently typed values.</p><pre><code class="language-julia hljs"># first, create a MatrixTable from our matrix input
mattbl = Tables.table(mat)
# test that the MatrixTable `istable`
@test Tables.istable(typeof(mattbl))
# test that it defines row access
@test Tables.rowaccess(typeof(mattbl))
@test Tables.rows(mattbl) === mattbl
# test that it defines column access
@test Tables.columnaccess(typeof(mattbl))
@test Tables.columns(mattbl) === mattbl
# test that we can access the first &quot;column&quot; of our matrix table by column name
@test mattbl.Column1 == [1,2,3]
# test our `Tables.AbstractColumns` interface methods
@test Tables.getcolumn(mattbl, :Column1) == [1,2,3]
@test Tables.getcolumn(mattbl, 1) == [1,2,3]
@test Tables.columnnames(mattbl) == [:Column1, :Column2, :Column3]
# now let&#39;s iterate our MatrixTable to get our first MatrixRow
matrow = first(mattbl)
@test eltype(mattbl) == typeof(matrow)
# now we can test our `Tables.AbstractRow` interface methods on our MatrixRow
@test matrow.Column1 == 1
@test Tables.getcolumn(matrow, :Column1) == 1
@test Tables.getcolumn(matrow, 1) == 1
@test propertynames(mattbl) == propertynames(matrow) == [:Column1, :Column2, :Column3]</code></pre><p>So, it looks like our <code>MatrixTable</code> type is looking good. It&#39;s doing everything we&#39;d expect with regards to accessing its rows or columns via the Tables.jl API methods. Testing a table source like this is fairly straightforward since we&#39;re really just testing that our interface methods are doing what we expect them to do.</p><p>Now, while we didn&#39;t go over a &quot;sink&quot; function for matrices in our walkthrough, there does indeed exist a <code>Tables.matrix</code> function that allows converting any table input source into a plain Julia <code>Matrix</code> object.</p><p>Having both Tables.jl &quot;source&quot; and &quot;sink&quot; implementations (i.e. a type that is a Tables.jl-compatible source, as well as a way to <em>consume</em> other tables), allows us to do some additional &quot;round trip&quot; testing:</p><pre><code class="language-julia hljs">rt = [(a=1, b=4.0, c=&quot;7&quot;), (a=2, b=5.0, c=&quot;8&quot;), (a=3, b=6.0, c=&quot;9&quot;)]
ct = (a=[1,2,3], b=[4.0, 5.0, 6.0])</code></pre><p>In addition to our <code>mat</code> object earlier, we can define a couple simple &quot;tables&quot;; in this case <code>rt</code> is a kind of default &quot;row table&quot; as a <code>Vector</code> of <code>NamedTuple</code>s, while <code>ct</code> is a default &quot;column table&quot; as a <code>NamedTuple</code> of <code>Vector</code>s. Notice that they contain mostly the same data as our matrix literal earlier, yet in slightly different storage formats. These default &quot;row&quot; and &quot;column&quot; tables are supported by default in Tables.jl due do their natural table representations, and hence can be excellent tools in testing table integrations.</p><pre><code class="language-julia hljs"># let&#39;s turn our row table into a plain Julia Matrix object
mat = Tables.matrix(rt)
# test that our matrix came out like we expected
@test mat[:, 1] == [1, 2, 3]
@test size(mat) == (3, 3)
@test eltype(mat) == Any
# so we successfully consumed a row-oriented table,
# now let&#39;s try with a column-oriented table
mat2 = Tables.matrix(ct)
@test eltype(mat2) == Float64
@test mat2[:, 1] == ct.a

# now let&#39;s take our matrix input, and make a column table out of it
tbl = Tables.table(mat) |&gt; columntable
@test keys(tbl) == (:Column1, :Column2, :Column3)
@test tbl.Column1 == [1, 2, 3]
# and same for a row table
tbl2 = Tables.table(mat2) |&gt; rowtable
@test length(tbl2) == 3
@test map(x-&gt;x.Column1, tbl2) == [1.0, 2.0, 3.0]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../using-the-interface/">« Using the Interface</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Wednesday 4 June 2025 13:24">Wednesday 4 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
